---
title: "Lecture 5:  Advanced data manipulation & visualization"
output: html_document
date: "2026-01-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Lesson preamble

> ### Learning Objectives
>
> -   Learn to make histograms, line plots, and reference lines using `ggplot`
>
> -   Understand and apply faceting in `ggplot`
>
> -   Learn to switch between long and wide format data using `pivot_longer` and `pivot_wider`
>
> -   Format plots to be more readable

------------------------------------------------------------------------

## Review

We'll be continuing to work for one more lecture on the rich dataset from the [Portal Project](https://portal.weecology.org/), which is a 30+ year study of a Chihuahuan desert ecosystem near Portal, Arizona, USA. The dataset we're working with contains observations of animals found at the study site, which was subdivided into plots which underwent controlled environmental manipulation in some years.

```{r portal_figure, echo=FALSE, fig.cap="The Portal Project is a long-term ecological study in the a desert ecosystem in Arizona, which includes frequent sampling over 30+ years and controlled manipulations of the ecosystem", out.width = '80%'}
knitr::include_graphics("figures/portal_project.png")
```

We'll make sure the tidyverse package is loaded and then read the data in again

*Note: make sure to clear your environment before starting a new class*

```{r}
library(tidyverse)
```

```{r}

# If you didn't download and save the data locally last time
# download.file("https://ndownloader.figshare.com/files/2292169", "data/portal_data.csv")

surveys <- readr::read_csv('data/portal_data.csv')
```

```{r}
surveys
```

For each animal captured, the weight and hindfoot length were measured, and we investigated the relationship between the two variables (after removing missing data) using a **scatterplot** and found strong clustering by species

```{r}
surveys_abun_species <- surveys %>% 
  filter(!is.na(hindfoot_length) & !is.na(weight)) %>%
  group_by(species) %>%
  mutate(n = n()) %>% # add count value to each row
  filter(n > 800) %>%
  select(-n) %>%
  mutate(genus_species = paste(genus,species))

surveys_abun_species %>%
  ggplot(aes(x = weight, y = hindfoot_length, colour = genus_species)) +
  geom_point(alpha = 0.2)
```

Looking at the same variables a different way,

```{r}
surveys_abun_species %>%
  ggplot(aes(x = genus_species, y = hindfoot_length, colour = weight)) +
  geom_jitter(size = 0.1, height = 0, width = 0.4) + 
  theme(axis.text.x = element_text(angle = 45,vjust=1, hjust=1))
```

## More plot types

In this section, we'll explore a few more types of plots we can make in `ggplot`.

Let's calculate number of counts per year for each species. First, we need to group the data and count records within each group:

```{r}
surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
    arrange(desc(n)) # Adding arrange just to compare with histogram
```

Before doing any complex analysis, it's important to understand how much data there is. Are there years where very few animals of a given species were observed? The best way to look at this sort of count data is with a **histogram**.

To create a histogram, we can assign this table to a variable, and then pass that variable to `ggplot()`.

```{r, message=FALSE, warning=FALSE}
yearly_counts <- surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
    arrange(desc(n))

ggplot(yearly_counts, aes(x = n)) +
    geom_histogram()
```

Remember that a histogram plots the number of observations based on a variable, so you only need to specify the x-axis in the `ggplot()` call. Also, that a histogram's bin size can really change what you might understand about the data. The histogram geom has a *bins* argument that allows you to specify the number of bins and a *binwidth* argument that allows you to specify the size of the bins.

```{r}
ggplot(yearly_counts, aes(x = n)) +
    geom_histogram(bins=10)
```

Creating an intermediate variable would be preferable for time consuming calculations, because you would not want to do that operation every time you change the plot aesthetics.

If it is not a time consuming calculation or you would like the flexibility of changing the data summary and the plotting options in the same code chunk, you can pipe the output of your split-apply-combine operation to the plotting command:

```{r, message=FALSE, warning=FALSE}
surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
    ggplot(aes(x = n)) +
        geom_histogram()
```

We can perform a quick check that the plot corresponds to the table by colouring the histogram by species:

```{r, message=FALSE, warning=FALSE}
surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
  # We are using "fill" here instead of "colour"
    ggplot(aes(x = n, fill = genus_species)) + 
        geom_histogram()
```

*Note: Here we are using `fill` to assign colours to species rather than `colour`. In general `colour` refers to the outline of points/bars or whatever it is you are plotting and `fill` refers to the colour that goes inside the point or bar. If you are confused, try switching out `fill` for `colour` to see what looks best!*

Now let's explore how the number of each genus varies over time. Longitudinal data can be visualized as a line plot with years on the x axis and counts on the y axis:

```{r}
surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
    ggplot(aes(x = year, y = n)) +
        geom_line()
```

Unfortunately, this does not work because we plotted data for all the species together as one line. We need to tell `ggplot` to draw a line for each species by modifying the aesthetic function to include `group = species`:

```{r}
surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
    ggplot(aes(x = year, y = n, group = genus_species)) +
        geom_line()
```

We will be able to distinguish species in the plot if we add colours (using `colour` also automatically groups the data):

```{r}
annual_plot <- surveys_abun_species %>%
    group_by(year, genus_species) %>%
    tally() %>%
  # `colour` groups automatically
    ggplot(aes(x = year, y = n, colour = genus_species)) +
        geom_line() 

annual_plot
```

There seem to be large fluctuations over time in the levels of many of these species! We can calculate an average

```{r}
avg_species <- surveys_abun_species %>%
  group_by(year,genus_species) %>%
  tally() %>%
  group_by(genus_species) %>%
  summarize(avg_yearly_count = mean(n))

avg_species
```

```{r}
annual_plot <- annual_plot + 
  geom_abline(data=avg_species, aes(slope = 0, intercept = avg_yearly_count, colour = genus_species), linetype = "dashed")

annual_plot
```

## Creating multi-panel plots (faceting)

`ggplot` has a special technique called *faceting* that allows the user to split one plot into multiple subplots based on a variable included in the dataset. This allows us to examine the trends associated with each grouping variable more closely. We will use it to make a time series plot for each species:

```{r}
surveys_abun_species %>%
    group_by(year, species) %>%
    tally() %>%
    ggplot(aes(x = year, y = n)) + 
        geom_line() +
        facet_wrap(~species)
```

Now we would like to split the line in each plot by the sex of each individual measured. To do that we need to make counts in the data frame after grouping by `year`, `species`, and `sex`:

```{r}
surveys_abun_species %>%
    group_by(year, species, sex) %>%
    tally()
```

We can reflect this grouping by sex in the faceted plot by splitting further with `colour` (within a single plot):

```{r}
surveys_abun_species %>%
    group_by(year, species, sex) %>%
    tally() %>%
    ggplot(aes(x = year, y = n, colour = sex)) +
        geom_line() +
        facet_wrap(~species)
```

There are several observations where sex was not recorded. Let's filter out those values.

```{r}
surveys_abun_species %>%
    filter(!is.na(sex)) %>%
    group_by(year, species, sex) %>%
    tally() %>%
    ggplot(aes(x = year, y = n, color = sex)) +
        geom_line() +
        facet_wrap(~species)
```

It is possible to specify exactly which colors[^1] to use and to change the thickness of the lines to make the them easier to distinguish.

[^1]: There are so many colors to chose from in R. Check out the [R Color](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) doc to find something that brings you joy.

```{r}
surveys_abun_species %>%
    filter(!is.na(sex)) %>%
    group_by(year, species, sex) %>%
    tally() %>%
    ggplot(aes(x = year, y = n, colour = sex)) +
        geom_line(size = 1) +
        scale_colour_manual(values = c("black", "orange")) +
        facet_wrap(~species) 
```

Not sure what colours would look good on your plot? The R Community got you covered! Check out these awesome [color palettes](https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/) where nice-looking color combos come predefined. We especially recommend the [`viridis` color palettes](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html). These palettes are not only pretty, they are specifically designed to be easier to read by those with colourblindness.

Lastly, let's change the x labels so that they don't overlap, and remove the grey background to increase contrast with the lines. To customize the non-data components of the plot, we will pass some *theme* statements[^2] to `ggplot`.

[^2]: The amount of control over various plot elements in `ggplot` is truly astonishing. Check out the complete list of themes [here](https://ggplot2.tidyverse.org/reference/theme.html). Have fun!

```{r}
surveys_abun_species %>%
  filter(!is.na(sex)) %>%
  group_by(year, species, sex) %>%
  tally() %>%
  ggplot(aes(x = year, y = n, color = sex)) +
  geom_line(size = 1) +
  scale_colour_viridis_d() +
  facet_wrap(~species) +
  theme_classic() +
  theme(text = element_text(size = 12),
        axis.text.x = element_text(angle = 30, hjust = 1))
```

There are other popular theme options, such as `theme_bw()`.

Our plot looks pretty polished now! It would be difficult to share with other, however, given the lack of information provided on the Y axis. Let's add some meaningful axis labels.

```{r polished}
surveys_abun_species %>%
  filter(!is.na(sex)) %>%
  group_by(year, species, sex) %>%
  tally() %>%
  ggplot(aes(x = year, y = n, color = sex)) +
  geom_line(size = 1) +
  scale_colour_viridis_d() +
  facet_wrap(~species) +
  theme_classic() +
  theme(text = element_text(size = 12),
        axis.text.x = element_text(angle = 30, hjust = 1)) +
  labs(title = "Rodent abundance over time",
       x = "Year",
       y = "Number observed",
       colour = "Sex")
```

### Challenge

Use the filtered data frame (`surveys_abun_species`) for part 2.

**1.** Remember the histogram coloured according to each species? Starting from that code, how could we separate each species into its own subplot? *Hint: look in the split-apply-combine section*

**2.a.** Create a plot that shows the average weight over years. Which year was the average weight of all animals the highest?

**2.b.** Iterate on the plot so it shows differences among species of their average weight over time. Is the yearly trend the same for all species?

```{r, include=FALSE}
# Answers
# 1
ggplot(yearly_counts, aes(x = n, fill = genus_species)) +
    geom_histogram() +
    facet_wrap(~genus_species)
```

```{r, include=FALSE}
# 2.a
surveys_abun_species %>%
    filter(!is.na(weight)) %>%
    group_by(year) %>%
    summarize(mean_weight = mean(weight)) %>%
    ggplot(aes(x = year, y = mean_weight)) +
        geom_line()
```

```{r, include=FALSE}
# 2.b
surveys_abun_species %>%
    filter(!is.na(weight)) %>%
    group_by(year, species) %>%
    summarize(mean_weight = mean(weight), .groups = "keep") %>%
    ggplot(aes(x = year, y = mean_weight, colour = species)) +
        geom_line() +
        facet_wrap(~ species)
```

## Reshaping with pivot_wider and pivot_longer

### Defining wide vs long data

The survey data presented here is almost in what we call a *long* format -- every observation of every individual is its own row. This is an ideal format for data with a rich set of information per observation. It makes it difficult, however, to look at the relationships between measurements across plots/trials. For example, what is the relationship between mean weights of different genera across all plots?

To answer that question, we want each plot to have its own row, with each measurements in its own column. This is called a *wide* data format. For the `surveys` data as we have it right now, this is going to be one heck of a wide data frame! However, if we were to summarize data within plots and species, we can reduce the dataset and begin to look for some relationships we'd want to examine. We need to create a new table where each row is the values for a particular variable associated with each plot. In practical terms, this means the values in genus would become the names of column variables and the cells would contain the values of the mean weight observed on each plot by genus.

We can use the functions called `pivot_wider()` and `pivot_longer()` (these are newer replacements for `spread()` and `gather()`, which were the older functions). These can feel tricky to think through, but do not feel alone in this! Many others have squinted at their data, unsure exactly how to reshape it, so there are many [guides](https://libguides.princeton.edu/R-reshape) and [cheatsheets](https://bioinformatics.ccr.cancer.gov/docs/rintro/resources/tidyr_cheatsheet.pdf) available to help!

### Summary of long vs wide formats

Long format:

-   every column is a variable
    -   first column(s) repeat
-   every row is an observation

Wide format:

-   each row is a measured thing
-   each column is an independent observation
    -   first column does not repeat

### Long to Wide with `pivot_wider`

Let's start by using `dplyr` to create a data frame with the mean body weight of each genus by plot.

```{r}
surveys_gw <- surveys %>%
    filter(!is.na(weight)) %>%
    group_by(genus, plot_id) %>%
    summarize(mean_weight = mean(weight))

surveys_gw %>% head()
```

Now, to make this long data wide, we use `pivot_wider()` from `tidyr` to spread out the different taxa into columns. `pivot_wider()` takes 3 arguments: the data , the `names_from` column variable that will eventually become the column names, and the `values_from` column variable that will fill in the values. We'll use a pipe so we don't need to explicitly supply the data argument.

```{r}
surveys_gw_wide <- surveys_gw %>% 
  pivot_wider(names_from = genus, values_from = mean_weight)

head(surveys_gw_wide)
```

Now we can go back to our original question: what is the relationship between mean weights of different genera across all plots? We can easily see the weights for each genus in each plot! Notice that some genera have `NA` values. That's because some genera were not recorded in that plot.

Note! If you've been using R for a few years in other contexts, you may have used the function `spread()`instead of pivot_wider. spread also takes three arguments: the data, the *key* column (or column with identifying information), and the *values* column (the one with the numbers/values), and can return the same \`wide' data frame. However pivot_wider is currently the recommended function to use, as it has extra features to make it more flexible and less error_prone.

```{r}
surveys_gw_wide0 <- surveys_gw %>%
  spread(key = genus, value = mean_weight) 

head(surveys_gw_wide0)
```

### Wide to long with `gather` and `pivot_longer`

What if we had the opposite problem, and wanted to go from a wide to long format? For that, we can use `pivot_longer()` to gather a set of columns into one key-value pair. To go backwards from `surveys_gw_wide`, we should exclude *plot_id*.

`pivot_longer()` takes 4 arguments: the data, the `names_to` column variable that comes from the column names, the `values_to` column with the values, and `cols` which specifies which columns we want to keep or drop. Again, we will pipe from the dataset so we don't have to specify the data argument:

```{r}
surveys_gw_long2 <- surveys_gw_wide %>% 
  pivot_longer(names_to = "genus", values_to = "mean_weight", cols = -plot_id)

surveys_gw_long2
```

If the columns are directly adjacent as they are here, we donâ€™t even need to list the all out: we can just use the : operator, as before.

```{r}
surveys_gw_wide %>% 
  pivot_longer(names_to = "genus", values_to = "mean_weight", cols = Baiomys:Sigmodon)
```

Note that now the `NA` genera are included in the long format.

In the past, you may have used `gather()`. We give it the arguments of a new key and value column name, and then specify which columns we either want or do not want gathered up. So, togo backwards from `surveys_gw_wide`, and exclude `plot_id` from the gathering, we would do the following:

```{r}
surveys_gw_long0 <- surveys_gw_wide0 %>%
  gather(genus, mean_weight, -plot_id) 

head(surveys_gw_long0)
```

### Challenge

Starting with the `surveys_gw_wide` dataset, how would you display a new dataset that gathers the mean weight of all the genera (excluding NAs) except for the genus `Perognathus`?

```{r, include=FALSE}
surveys_gw_wide %>%
  pivot_longer(names_to = "genus", values_to = "mean_weight",
               cols = c(-plot_id, -Perognathus))
```
