---
title: "Summarizing and visualizating data"
output: pdf_document
urlcolor: blue
editor_options: 
  markdown: 
    wrap: 72
---

## Lesson preamble

> ### Learning Objectives
>
> -   Use *ggplot* to create simple scatterplots
> -   Vary `x`, `y`, and `colour` variables in scatterplots to
>     understand trends in data
> -   Use `group_by`, `summarize`, `tally,` and `arrange` to split a
>     data frame into groups of observations, apply a summary statistics
>     for each group, and then combine the results
> -   Use `summarize_all` to calculate a summary statistic for an entire
>     data frame
> -   Remove missing data using `is.na` or `na.omit`
> -   Combine data manipulation with data visualization using
>     split-apply-combine techniques, along with the pipe (`%>%`) and
>     layering (`+`) operators

------------------------------------------------------------------------

Last lecture we learned about the impressive data collected in the
long-term Portal desert ecology study and had a chance to look through
some of the variables, but since there were so many data points (over
30,000!) and so many variables collected, it was hard to get a sense for
what was really going on. There's lot more analysis we can run, but
usually it helps to first actually *see* what the data actually looks
like. Luckily, our favourite package-of-packages `tidyverse` has us
covered -- it comes with a wonderful package for generating graphics
called `ggplot2`!

We can load `tidyverse` into our current R session:

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
```

Now we'll reload the data that we previously downloaded (and saved
locally):

```{r}
surveys <- readr::read_csv('data/portal_data.csv')
```

(If you weren't able to successfully save it last time, you can instead
read it in directly from the website):

```{r, eval=FALSE}
surveys <- readr::read_csv("https://ndownloader.figshare.com/files/2292169")
```

And let's remind ourselves of the data structure by printing off a few
of the entries

```{r}
surveys[seq(1,nrow(surveys),1000),] # pick out every 1000th entry
```

## Plotting with ggplot2

`ggplot2` is a plotting package that makes it simple to create complex
plots from data frames. The name `ggplot2` comes from its inspiration,
the book [*A Grammar of
Graphics*](https://www.springer.com/gp/book/9780387245447), and the main
goal is to allow coders to distill complex data structure and express
their desired graphical outcome in a concise manner instead of telling
the computer every detail about what should happen. For example, you
would say "colour my data by species" instead of "go through this data
frame and plot any observations of species1 in blue, any observations of
species2 in red, etc". Thanks to this functional way of interfacing with
data, only minimal changes are required if the underlying data change or
if you want to try a different type of visualization.
Publication-quality plots can be created with minimal amounts of
adjustment and tweaking.

`ggplot2` graphics are built step by step by adding new elements, or
layers. Adding layers in this fashion allows for extensive flexibility
and customization of plots. To build a ggplot, we need to:

**1.** Use the `ggplot()` function and bind the plot to a specific data
frame using the *data* argument

```{r}
ggplot(data = surveys)
```

Remember, if the arguments are provided in the right order then the
names of the arguments can be omitted.

```{r}
ggplot(surveys)

# You can also use the %>% operator to pass the data to ggplot
surveys %>% 
  ggplot()
```

**2.** Define aesthetics (`aes`), by selecting the columns to be plotted
and the presentation variables (ex: point size, shape, colour, etc.)

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length))
```

**3.** Add `geoms` -- geometrical objects as a graphical representation
of the data in the plot (points, lines, bars). `ggplot2` offers many
different geoms. We will use a few common ones today, including: \*
`geom_point()` for scatter plots, dot plots, etc. \* `geom_line()` for
trend lines, time-series, etc. \* `geom_histogram()` for histograms

To add a geom to the plot use `+` operator. Because we have two
continuous variables (*weight* and *hindfoot_length*), let's use
`geom_point()` first:

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
  geom_point()
```

*Note: Notice that triangle-! warning sign above the plot? `ggplot` is
telling you that it wasn't able to plot all of your data. Typically this
means that there are NAs in the data, or that some data points lie
outside of the bounds of the axes. Can you figure what it is in this
instance?*

The `+` in the `ggplot2` package is particularly useful because it
allows you to modify existing `ggplot` objects. This means you can
easily set up plot "templates" and conveniently explore different types
of plots. The above plot can be generated with code like this:

```{r, first-ggplot-with-plus}
# Assign plot to a variable
surveys_plot <- ggplot(surveys, aes(x = weight, y = hindfoot_length))

# Draw the plot
surveys_plot + geom_point()
```

Three notes:

-   Anything you put in the top `ggplot()` call can be seen/used by any
    geom layers that you add, including the x and y axis variables you
    set up in `aes()`. These are essentially universal plot settings.

-   You can specify *aes*thetics for a geom independently of the
    aesthetics defined by `ggplot()`, which is particularly handy when
    you're layering data from different data frames

-   The `+` sign used to add layers must be placed *at the end* of each
    line containing a layer. If it's used at the start of line,
    **`ggplot2`** will not add the new layer and R will return an error
    message.

### Building plots iteratively

Building plots with ggplot is typically an iterative process. Start
simply. We will define the dataset to use, lay the axes, and choose one
geom, as we just did:

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length)) +
    geom_point()
```

Then, we start modifying this plot to extract more information from it.
For instance, we can add the argument for transparency (`alpha`) to
reduce overplotting:

```{r}
ggplot(data = surveys, aes(x = weight, y = hindfoot_length)) +
    geom_point(alpha = 0.2)
```

Based on the hindfoot length and the weights, there appears to be 4
clusters in this data. Potentially, one of the categorical variables we
have in the data could explain this pattern. Colouring the data points
according to a categorical variable is an easy way to find out if there
seems to be correlation. Let's try colouring this points according to
`plot_type`. As a reminder, this variable keeps track of whether the
plot was subjected to one of the environmental manipulations, and in
this teaching dataset, `plot_type` refers only to the types of rodents
that were excluded from the plot).

First, let's check how many different types of plots there are - if
there's too many types, we'll need a lot of colours, and our plot could
get messy fast! We can use the unique function, which works on any
vector (including dataframe columns) to list all the unique values

```{r}
unique(surveys$plot_type)
```

We can then could up how many unique values there are. 5 seems like a
reasonable number!

```{r}
length(unique(surveys$plot_type))
```

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length, colour = plot_type)) +
    geom_point(alpha = 0.2)
```

It seems like the type of plot the animal was captured on correlates
well with some of these clusters, but there are still many that are
quite mixed. Let's try to do better!

#### Challenge

1.  Come up with a hypothesis to explain why the plot type seems to be
    related to the height-weight clusters
2.  Try colouring your plot based on 1 or 2 of the other dataset
    variables. In each case, try to state what is the specific
    hypothesis you have in mind when choosing the variable

## Split-apply-combine

Before we dig further into trying to explain these clusters, we need to
learn a few more techniques for aggregating and analyzing data.

Many data analysis tasks can be approached using the
*split-apply-combine* paradigm: split the data into groups, apply some
analysis to each group, and then combine the results.

### Summarizing data by group with simple statistics

**`dplyr`** facilitates this workflow through the use of `group_by()` to
split data and `summarize()`, which collapses each group into a
single-row summary of that group. The arguments to `group_by()` are the
column names that contain the **categorical** variables for which you
want to calculate the summary statistics. Let's view the mean `weight`
by sex.

```{r}
surveys %>%
    group_by(sex) %>%
    summarize(mean_weight = mean(weight))
```

The mean weights become `NA` since there are individual observations
that are `NA`. Let's remove those observations.

```{r}
surveys %>%
    filter(!is.na(weight)) %>%
    group_by(sex) %>%
    summarize(mean_weight = mean(weight))
```

There is one row here that is neither male nor female, these are
observations where the animal escaped before the sex could not be
determined. Let's remove those as well.

```{r}
surveys %>%
    filter(!is.na(weight) & !is.na(sex)) %>%
    group_by(sex) %>%
    summarize(mean_weight = mean(weight))
```

You can also group by multiple columns:

```{r}
surveys %>%
    filter(!is.na(weight) & !is.na(sex)) %>%
    group_by(genus, sex) %>%
    summarize(mean_weight = mean(weight))
```

Since we will use the same filtered and grouped data frame in multiple
code chunks below, we could assign this subset of the data to a new
variable and use this variable in the subsequent code chunks instead of
typing out the functions each time.

```{r}
filtered_surveys <- surveys %>%
    filter(!is.na(weight) & !is.na(sex)) %>%
    group_by(genus, sex)
```

If you want to display more data, you can use the `print()` function at
the end of your chain with the argument `n` specifying the number of
rows to display.

```{r}
filtered_surveys %>%
    summarize(mean_weight = mean(weight)) %>%
    print(n = 15) # Will change the knitted output, not the notebook
```

Once the data are grouped, you can also summarize multiple variables at
the same time. For instance, we could add a column indicating the
minimum weight for each species for each sex:

```{r}
filtered_surveys %>%
    summarize(mean_weight = mean(weight),
              min_weight = min(weight))
```

If we don't want to make any groups and want to summarize all the
columns, we can instead use summarize_all

```{r}
filtered_surveys %>%
    summarize_all(mean)
```

This gives errors since some columns are strings, not numbers, we get a
warning. A summary statistic that works for all columns is to count the
number of distinct values that variable can take:

```{r}
surveys %>%
    summarize_all(n_distinct)
```

#### Challenge

1.  Use `group_by()` and `summarize()` to find the mean, min, and max
    hindfoot length for each species.

2.  What was the heaviest animal measured in each year? Return the
    columns `year`, `genus`, `species`, and `weight`.

```{r, include=FALSE}
## Answer 1
surveys %>%
    filter(!is.na(hindfoot_length)) %>%
    group_by(species) %>%
    summarize(
        mean_hindfoot_length = mean(hindfoot_length),
        min_hindfoot_length = min(hindfoot_length),
        max_hindfoot_length = max(hindfoot_length)
    ) %>%
    print(n = 15)
```

```{r, include=FALSE}
## Answer 2
surveys %>%
    filter(!is.na(weight)) %>%
    group_by(year) %>%
    filter(weight == max(weight)) %>% # This is going to compare to the max weight within each group
    select(year, genus, species, weight) %>%
    arrange(year) %>%
    print(n = 15)
```

### Using tally to summarize categorical data

When working with data, it is also common to want to know the number of
observations found for each factor or combination of factors. For this,
**`dplyr`** provides `tally()`. For example, if we want to group by taxa
and find the number of observations for each taxa, we would do:

```{r}
surveys %>%
    group_by(taxa) %>%
    tally()
```

We can also use `tally()` when grouping on multiple variables:

```{r}
surveys %>%
    group_by(taxa, sex) %>%
    tally()
```

Here, `tally()` is the action applied to the groups created by
`group_by()` and counts the total number of records for each category.

If there are many groups, `tally()` is not that useful on its own. For
example, when we want to view the five most abundant species among the
observations:

```{r}
surveys %>%
    group_by(species) %>%
    tally()
```

Since there are 40 rows in this output, we would like to order the table
to display the most abundant species first. In `dplyr`, we say that we
want to `arrange()` the data.

```{r}
surveys %>%
    group_by(species) %>%
    tally() %>%
    arrange(n)
```

Still not that useful. Since we are interested in the most abundant
species, we want to display those with the highest count first, in other
words, we want to arrange the column `n` in descending order:

```{r}
surveys %>%
    group_by(species) %>%
    tally() %>%
    arrange(desc(n)) %>%
    head(5)
```

If we want to include more attributes about these species, we can
include these in the call to `group_by()`:

```{r}
surveys %>%
    group_by(species, taxa, genus) %>%
    tally() %>%
    arrange(desc(n)) %>%
    head(5)
```

Be careful not to include anything that would split the group into
subgroups, such as `sex`, `year` etc.

#### Challenge

1.  How many individuals were caught in each `plot_type` surveyed?

2.  You saw above how to count the number of individuals of each `sex`
    using a combination of `group_by()` and `tally()`. How could you get
    the same result using `group_by()` and `summarize()`? Hint: see
    `?n`.

```{r, include=FALSE}
## Answer 1
surveys %>%
    group_by(plot_type) %>%
    tally()

## Answer 2
surveys %>%
  group_by(sex) %>%
  summarize(n = n())
```

## Split-apply-combine... plot!

Now we'll come back to trying to understand our weight-vs-hindfoot
length data, but armed with more tools! We'll see how combining just a
handful of tools from the `dplyr` and `ggplot` packages, we can create a
powerful data exploration workflow.

Glancing at our prior plot, we can get a clues to which explanatory
variable to look at next. The plot above suggests that there might be 4
clusters, so a variable with 4 values is a good guess for what could
explain the observed pattern in the scatter plot. Let's figure out which
variable that is.

```{r}
surveys %>%
    summarize_all(n_distinct) 
# `n_distinct` is a function that counts unique values in a set of vectors
```

Remember that there are still `NA` values here, that's why there are 3
unique sexes although only male and female were coded in our original
data set. There are four taxa, so maybe that could be a good candidate
to explain the clusters? Let's check it out!

```{r}
surveys %>%
    distinct(taxa)
# alternatively, we could have ran unique(surveys$sex)
```

It seems reasonable that these taxa contain animals different enough to
have diverse weights and length of their feet. Lets use this categorical
variable to colour the scatter plot.

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length, colour = taxa)) +
    geom_point(alpha = 0.2)
```

Only rodents? That was unexpected... Let's check what's going on.

```{r}
surveys %>%
    group_by(taxa) %>%
    tally()
```

Definitely mostly rodents in our data set.... Let's check again after
making sure we only take observations where the hindfoot length was
actually measured (ie, not NA)

```{r}
surveys %>%
    filter( !is.na(hindfoot_length) ) %>% # control by removing `!`
    group_by(taxa) %>%
    tally()
```

...and it turns out that only rodents have had their hindfeet measured!
Rats.

Let's remove all records of animals without hindfoot measurements,
including rodents. We'll also remove any observations that did not
include weights.

```{r}
surveys_hf_wt <- surveys %>%
    filter(!is.na(hindfoot_length) & !is.na(weight))

surveys_hf_wt %>%
    summarize_all(n_distinct)
```

Maybe the genus of the animals can explain what we are seeing.

```{r}
ggplot(surveys, aes(x = weight, y = hindfoot_length, colour = genus)) +
    geom_point(alpha = 0.2)
```

Now this looks good! There is a clear separation between different
genera but also significant spread within genus. For example, in the
weight of the green *Neotoma* observations. There are also two clearly
separate clusters that are both coloured in olive green (*Dipodomys*).
Maybe separating the observations into different species would be
better?

```{r}
ggplot(surveys_hf_wt, aes(x = weight, y = hindfoot_length, colour = species)) +
    geom_point(alpha = 0.2)
```

Great! Together with the genus plot, this definitely seems to explain
most of the variation we see in the hindfoot length and weight
measurements. It is still a bit messy as it appears like we have around
five clusters of data points but there are 21 species in the legend.

```{r}
surveys %>%
    filter(!is.na(hindfoot_length) & !is.na(weight)) %>%
    group_by(species) %>%
    tally() %>%
    arrange(desc(n))
```

There is a big drop from 838 to 159, let's include only those with more
than 800 observations.

```{r}
surveys_abun_species <- surveys %>%
    filter(!is.na(hindfoot_length) & !is.na(weight)) %>%
    group_by(species) %>%
    mutate(n = n()) %>% # add count value to each row
    filter(n > 800) %>%
    select(-n)

surveys_abun_species %>%
  # Remember, print limits lines displayed when knitted
  print(10)
```

Still has almost 31k observations, so only \~3k observations were
removed.

```{r}
surveys_abun_species %>%
  ggplot(aes(x = weight, y = hindfoot_length, colour = species)) +
  geom_point(alpha = 0.2)
```

The plot is now cleaner; there are fewer species and so fewer colours
and the clusters are more distinct. But one final thing. Maybe you find
it hard to keep track of the rodents, and how they're related, from
their species name only. Suppose we want our legend to report both the
genus AND the species. We can do this by creating a new variable that is
the genus+species name combined into a single string, using the function
`paste`

```{r}
surveys_abun_species %>%
  mutate(genus_species = paste(genus,species)) %>%
  ggplot(aes(x = weight, y = hindfoot_length, colour = genus_species)) +
  geom_point(alpha = 0.2)
```

#### Challenge

Create a scatter plot of *hindfoot_length* against *species* with the
*weight* data displayed using colours. If you're unsure of which
variable to put on which axis, Y variables are generally "against" X
variables. Also, continuous variables are generally plotted on the Y
axis.

```{r, include=FALSE}
surveys_abun_species %>%
  ggplot(aes(x = species, y = hindfoot_length, colour = weight)) +
    geom_point(size = 0.1)
```

Do you notice any potential issues with this plot given the sheer number
of observations we know exist in the data?

```{r include=FALSE}
# We can improve it by adding a small amount of random noise to x variable
# `jitter` is used to visualize values with a lot of overlap
# here, we are jittering along the x-axis because the x-axis is categorical
# we can also rotate the x axis labels to make them more easily readable

surveys_abun_species %>%
  ggplot(aes(x = species, y = hindfoot_length, colour = weight)) +
  geom_jitter(size = 0.1, height = 0, width = 0.4) + 
  theme(axis.text.x = element_text(angle = 45,vjust=1, hjust=1))

# Can also pass "jitter" as a position argument to geom_point
# surveys_abun_species %>%
#   ggplot(aes(x = species, y = hindfoot_length, colour = weight)) +
#   geom_point(size = 0.1, position = "jitter") +
#   theme(axis.text.x = element_text(angle = 45,vjust=1, hjust=1))
```

(This is further illustrating the **iterative** nature of constructing
plots)

*Parts of this lesson material were taken and modified from [Data
Carpentry](https://datacarpentry.org) under their CC-BY copyright
license. See their [lesson
page](https://datacarpentry.org/R-ecology-lesson/03-dplyr.html) for the
original source.*
