[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EEB313: Quantitative Methods in R for Biology",
    "section": "",
    "text": "Welcome!\nWelcome to the online home of EEB 313, Winter 2026. We created this website as an easy-to-navigate resources where we can share all the course details, detailed lectures notes, homework assignments, and other resources. Most of the files are created as interactive R Markdown documents, which you can download and run yourself.\nEEB 313 was originally developed as a student-led course, and over the years many contributors have helped to develop the course material in its current form. See the About Us page for more details on our current and past teaching team/course developers.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "EEB313: Quantitative Methods in R for Biology",
    "section": "Course overview",
    "text": "Course overview\nEEB313 covers foundational concepts in scientific computing and data analytics using the programming language R, with applications in ecology and evolutionary biology. Using interactive instructional sessions and group work, students will learn to program mathematical calculations and simple algorithms, to analyze and visualize complex datasets, to implement models to simulate biological population dynamics, and to document and disseminate their code. No prior programming experience is required.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus: EEB 313 Winter 2026",
    "section": "",
    "text": "Course overview\nThis course covers foundational concepts in scientific computing and data analytics using the programming language R, with applications in ecology and evolutionary biology. Using interactive instructional sessions and group work, students will learn to program mathematical calculations and simple algorithms, to analyze and visualize complex datasets, to implement models to simulate biological population dynamics, and to document and disseminate their code. No prior programming experience is required.\nPrerequisites: BIO220H1 and one of EEB225H1, STA288H1, or STA220H1",
    "crumbs": [
      "Syllabus: EEB 313 Winter 2026"
    ]
  },
  {
    "objectID": "syllabus.html#course-details",
    "href": "syllabus.html#course-details",
    "title": "Syllabus: EEB 313 Winter 2026",
    "section": "Course details",
    "text": "Course details\n\nCourse learning outcomes\n\nMaster the basic syntax, data types, and operations needed for basic scientific computing in R\nManipulate, visualize, and analyze complex biological data sets programmatically\nFit standard and customized statistical models to data\nSimulate simple stochastic and deterministic models of population dynamics\nImplement principles of reproducible computational research\nAcquire the confidence to approach scientific problems using computational methods\n\n\n\nTime\nMondays and Wednesdays 1-3pm in Carr Hall 325\nBoth weekly meetings are mandatory instructional sessions. Students should have a laptop computer capable of running the most recent versions of R and R Studio, or able to access POSIT/RStudio Cloud from a web browser, and should bring this to each class meeting.\nIn lieu of office hours, 2 members of the teaching team will be available after each class session to answer any questions students have.\n\n\nTeaching team\n\nInstructor\nProf. Alison Hill\nProf. Hill is a faculty member in the Department of Ecology & Evolutionary Biology. She runs a research group studying the dynamics and evolution of human infectious diseases within patients and across populations. Her team develops mathematical, statistical, and computational models to predict disease trajectories and help design interventions. Before moving to U of T, she was faculty at Johns Hopkins, and did her graduate and post-graduate training at Harvard. Coding is still her favourite part of her job, and she has used R - along with other programming languages - for many large open-source computational projects focusing on diseases such as COVID-19, HIV, RSV, and the opioid crisis.\n\n\nTeaching assistants\nJessie Wang\nJessie is a 4th year PhD student in the Frederickson lab at UTSG. She studies plant-microbe interactions using high- throughput experimentation in duckweeds. She fell in love with R during her time as an undergraduate and took EEB313 in 2020, simultaneously sharpening her coding skills while conducting research alone in the lab. Jessie loves to spend too much money on fancy coffee as she types away, making sure her code is well-annotated and her figures look beautiful. Outside of work, she enjoys caring for her many houseplants and aquariums, finding new delicious eats, and admiring other people’s pets.\nErik Curtis\nErik is a 2nd year PhD student interested in the epidemiology and population ecology of Pacific salmon, as well as the ecology of infectious diseases. In his PhD research, he is investigating the prevalence of co-infection in juvenile salmon. He’s also using eDNA metabarcoding to examine the coastal marine community concurrent with juvenile salmon migration and salmon farm activity. Prior to joining the MK lab, he studied at the University of Notre Dame, majoring in Biology and Math, where he examined the fate and transport of eDNA in experimental streams. \n\n\nContacts\nFor scientific/technical questions on the content of course material in lectures or on assignments, please email TAs Jessie (jae.wang@mail.utoronto.ca) and Erik (erik.curtis@mail.utoronto.ca). For questions on course policies or something the TAs were unable to answer, please email Prof. Hill (alison.hill@utoronto.ca). Send your email through Quercus (ideal), or if that’s not possible, include “EEB313” in the subject line. Responses may take a few days.\n\n\n\nLecture schedule\nThis schedule is tentative\n\n\n\n\n\n\n\n\nWeek\nDate\nTopic (tentative)\n\n\n\n\n1\nJan 5\nIntro to course\n\n\n1\nJan 7\nIntro to R\n\n\n2\nJan 12\nData manipulation\n\n\n2\nJan 14\nData visualization\n\n\n3\nJan 19\nExploratory data analysis\n\n\n4\nJan 21\nExploratory data analysis 2 (Activity)\n\n\n4\nJan 26\nLinear models I\n\n\n4\nJan 28\nLinear models II\n\n\n5\nFeb 2\nRandom variables and stochastic simulations\n\n\n5\nFeb 4\nMathematical models in ecology and evolution I\n\n\n6\nFeb 9\nMathematical models in ecology and evolution II (Activity)\n\n\n6\nFeb 11\nComputational statistics\n\n\n\nFeb 16\nReading week\n\n\n\nFeb 18\nReading week\n\n\n7\nFeb 23\nModel selection\n\n\n7\nFeb 25\nProject work\n\n\n8\nMar 2\nOptimization and model fitting\n\n\n8\nMar 5\nClustering, dimensionality reduction, and machine learning\n\n\n9\nMar 9\nProject work\n\n\n9\nMar 11\nProject work\n\n\n10\nMar 16\nReproducible research\n\n\n10\nMar 18\nProject work\n\n\n11\nMar 23\nProject work\n\n\n11\nMar 25\nProject work\n\n\n12\nMar 30\nGroup presentations\n\n\n12\nApr 1\nGroup presentations\n\n\n\n\n\nAssessment\n\nGrade breakdown summary\n\nProblem Sets  40%\nChallenge Assignment/Take-home exam ~ 20%\nGroup Project 30%\n\nPresentation 15%\nReport 15%\n\nOther 10%\n\nParticipation, surveys, progress reports, etc\n\n\n\n\nAssessment schedule\n\n\n\n\n\n\n\n\n\n\nAssignment\nType\nSubmitted on\nDue date\n%\n\n\n\n\nIntro survey\nIndividual\nQuercus\nJan 7 (flexible)\n1\n\n\nProblem Set 1\nIndividual\nQuercus\nJan 14\n8\n\n\nProblem Set 2\nIndividual\nQuercus\nJan 21\n8\n\n\nProblem Set 3\nIndividual\nQuercus\nJan 28\n8\n\n\nProblem Set 4\nIndividual\nQuercus\nFeb 4\n8\n\n\nProblem Set 5\nIndividual\nQuercus\nFeb 11\n8\n\n\nProject proposal\nGroup\nQuercus\nMar 5\n3\n\n\nChallenge assignment\nIndividual\nQuercus\nMar 11\n20\n\n\nMid-project update\nGroup\nGitHub\nMar 18\n6\n\n\nPresentation\nGroup\nIn-class\nMar 30 and Apr 1\n15\n\n\nFinal report\nGroup\nGitHub\nApr 8\n15\n\n\n\nThere are 100 marks in total. Your final course mark will be the sum of your assignment scores, which will be translated to a letter grade according to the official grading scale of the Faculty of Arts and Science.\nAssignments will be distributed and submitted in the R Markdown format via Quercus. Assignments will typically be handed out on Wed after class and are due at 11:59 PM on the following Wed. All students will be given 2 “free” late days that they can distribute across assignments if an extension is needed. Otherwise, late assignments will face a penalty of 50% per day.\nThe Challenge Assignment is equivalent to a take home exam. The format will be the same as the other assignments, but this assignment is designed challenge you to go a little beyond what was taught in class. It will be distributed on 9:00 AM on Mar 6, and it will be due 11:59 PM on Mar 11. Students should work on their own and submit their own original work. No extensions will be granted on this assignment except under the same extra-ordinary circumstances akin to those under which an exam might be deferred. We only expect you to do your best!\nThe project will be conducted as a group and groups will receive a single grade (except in exceptional circumstances). No late assignments will be accepted for any component of the group project.\nAll submissions to Quercus/GitHub must be submitted as PDFs (i.e., knitted).\n\n\n\nPre-requisites and preparation",
    "crumbs": [
      "Syllabus: EEB 313 Winter 2026"
    ]
  },
  {
    "objectID": "syllabus.html#resources",
    "href": "syllabus.html#resources",
    "title": "Syllabus: EEB 313 Winter 2026",
    "section": "Resources",
    "text": "Resources\n\nCourse websites\n\nQuercus https://q.utoronto.ca/courses/419604 (Assignments, announcements)\nhttps://eeb313.github.io/ (Detailed course info, lecture notes after class, links to code)\n\n\n\nR resources\n\nInstallation:\n\nInstall R: https://cran.rstudio.com\nInstall R Studio: https://posit.co/download/rstudio-desktop\nRegister for a free R Studio Cloud (“POSIT”) account: https://posit.cloud/plans/Links to an external site.freeLinks to an external site.\nRegister for a Github account: https://github.com/Links to an external site.signupLinks to an external site.\n\nThe EEB R Manual : https://rman.eeb.utoronto.ca/\nMathematics review: In Otto & Day, “A biologist’s guide to mathematical modeling in ecology & evolution”, Appendix 1 (basic math rules) and 2 (calculus). Available online via U of T libraries\n\n\n\nImproving your writing skills\nEffective communication is crucial in science. The University of Toronto provides services to help you improve your writing, from general advices on effective writing to writing centers and writing courses. The Faculty of Arts & Science also offers an English Language Learning (ELL) program, which provides free individualized instruction in English skills. Take advantage of these!\n\n\nFAS student engagement programs\nThere are a few programs on campus aimed at increasing student engagement with their coursework and keeping them socially connected. Recognized Study Groups are voluntary, peer-led study groups of up to 8 students enrolled in the same course. Meet to Complete are online drop-in study sessions for A&S undergrads. These are worth checking out if you are interested in participating in a study group.",
    "crumbs": [
      "Syllabus: EEB 313 Winter 2026"
    ]
  },
  {
    "objectID": "syllabus.html#course-policies",
    "href": "syllabus.html#course-policies",
    "title": "Syllabus: EEB 313 Winter 2026",
    "section": "Course Policies",
    "text": "Course Policies\n\nAttendance\nStudents are expected to attend and participate in all classes. If you are experiencing symptoms or suspect you have a communicable disease but decide to come to class, please practice hand hygiene and wear a face mask. \n\n\nAcademic Integrity\nYou should be aware of the University of Toronto Code of Behaviour on Academic Matters; all suspected cases of academic dishonesty will be investigated following procedures outlined in there. Also see How Not to Plagiarize. Notably, it is NOT appropriate to use large sections from internet sources, and inserting a few words here and there does not make it an original piece of writing. Be careful in using internet sources – most online material are not reviewed and there are many errors out there. Make sure you read material from many sources (published, peer-reviewed, trusted internet sources) and that you write an original text using this information. Always cite your sources. In case of doubt about plagiarism, talk to your instructors and TAs. Please make sure that what you submit for the final project does not overlap with what you submit for other classes, such as the 4th-year research project. If you have questions or concerns about what constitutes appropriate academic behaviour or appropriate research and citation methods, please reach out to me.\n\n\nOn the use of generative AI\nWe recognize that there are emerging generative artificial intelligence tools that can not only help with syntax and errors, but can write code de novo given text prompts. While these tools can be extremely useful when used responsibly by experienced coders, we believe it is critical to understand the foundational principles and syntax of programming by generating your own code, from scratch. Thus, we do not permit students to submit work generated by chat-bot programs, and will investigate suspicions of such use according to existing procedures for academic dishonesty. Students should be prepared to discuss, justify, and recreate any of their submitted work if prompted by course instructors at any time. Towards the end of the class, we will discuss the promise and pitfalls of such tools and experiment with their use for applications discussed in the course.\n\n\nOnline Communication\nAll communication regarding the course should be done through Quercus or using your mail.utoronto.ca email address. Please post questions that may be relevant to other students in the Discussions section of the course website, instead of asking the instructor by email\n\n\nAccessibility needs\nIf you require accommodations for a disability, or have any accessibility concerns about the course or course materials, please notify the course instructor, or contact Accessibility Services, as soon as possible regarding accommodations.\n\n\nDiversity and inclusion statement\nAs students, you all have something unique and special to offer to science. It is our intent that students from all backgrounds and perspectives be well served by this course, that students’ learning needs be addressed both in and out of class, and that the diversity that students bring to this class be recognized as a resource, strength, and benefit.\nDiversity can refer to multiple ways that we identify ourselves, including but not limited to race, national origin, language, cultural heritage, physical ability, neurodiversity, age, sexual orientation, gender identity, religion, and socio-economic class. Each of these varied, and often intersecting, identities, along with many others not mentioned here, shape the perspectives we bring to this class, to this department, and to the greater EEB community. We will work to promote diversity, equity, and inclusion not only because diversity fuels excellence and innovation, but because we want to pursue justice.\nWe expect that everybody in this class will respect each other, and demonstrate diligence in understanding how other people’s perspectives, behaviors, and worldviews may be different from their own. Racist, sexist, colonialist, homophobic, transphobic, and other abusive and discriminatory behavior and language will not be tolerated in this class and will result in disciplinary action, such as removal from class session or revocation of group working privileges. Please consult the University of Toronto Code of Student Conduct for details on unacceptable conduct and possible sanctions.\nPlease let us know if something said or done in this class, by either a member of the teaching team or other students, is particularly troubling or causes discomfort or offense. While our intention may not be to cause discomfort or offense, the impact of what happens throughout the course is not to be ignored and is something that we consider to be very important and deserving of attention. If and when this occurs, there are several ways to alleviate some of the discomfort or hurt you may experience:\n\nDiscuss the situation privately with a member of the teaching team. We are always open to listening to students’ experiences, and want to work with students to find acceptable ways to process and address the issue.\nNotify us of the issue through another source such as a trusted faculty member or a peer. If for any reason you do not feel comfortable discussing the issue directly with us, we encourage you to seek out another, more comfortable avenue to address the issue.\nContact the Anti-Racism and Cultural Diversity Office to report an incident and receive complaint resolution support, which may include consultations and referrals.\n\nWe acknowledge our imperfections while we also fully commit to the work, inside and outside of our classrooms, of building and sustaining a community that increasingly embraces these core values. Your suggestions and feedback are encouraged and appreciated. Please let us know ways to improve the effectiveness of the course for you personally or for other students or student groups.\n\n\nWellness statement\nWe on the teaching team value your health and wellness. In order to succeed in this class, in university, and beyond, you must balance your work with rest, exercise, and attention to your mental and physical health. Working until exhaustion is NOT a badge of honor. If you are finding it difficult to balance your health and well-being with your work in this class, please do not hesitate to let us know. We are happy to help connect you with resources and services on campus and also to make accommodations to our course plan as needed. Our inboxes are always open, and we are also available for virtual chats by appointment. You have our support, and we believe in you.",
    "crumbs": [
      "Syllabus: EEB 313 Winter 2026"
    ]
  },
  {
    "objectID": "about-us.html",
    "href": "about-us.html",
    "title": "2026 teaching team",
    "section": "",
    "text": "Instructor\nProf. Alison Hill (alison.hill@utoronto.ca)\nProf. Hill is a faculty member in the Department of Ecology & Evolutionary Biology. She runs a research group studying the dynamics and evolution of human infectious diseases within patients and across populations. Her team develops mathematical, statistical, and computational models to predict disease trajectories and help design interventions. Before moving to U of T, she was faculty at Johns Hopkins, and did her graduate and post-graduate training at Harvard. Coding is still her favourite part of her job, and she has used R - along with other programming languages - for many large open-source computational projects focusing on diseases such as COVID-19, HIV, RSV, and the opioid crisis.",
    "crumbs": [
      "2026 teaching team"
    ]
  },
  {
    "objectID": "about-us.html#teaching-assistants",
    "href": "about-us.html#teaching-assistants",
    "title": "2026 teaching team",
    "section": "Teaching assistants",
    "text": "Teaching assistants\nJessie Wang (jae.wang@mail.utoronto.ca)\nJessie is a 4th year PhD student in the Frederickson lab at UTSG. She studies plant-microbe interactions using high- throughput experimentation in duckweeds. She fell in love with R during her time as an undergraduate and took EEB313 in 2020, simultaneously sharpening her coding skills while conducting research alone in the lab. Jessie loves to spend too much money on fancy coffee as she types away, making sure her code is well-annotated and her figures look beautiful. Outside of work, she enjoys caring for her many houseplants and aquariums, finding new delicious eats, and admiring other people’s pets.\nErik Curtis (erik.curtis@mail.utoronto.ca\nErik is a 2nd year PhD student interested in the epidemiology and population ecology of Pacific salmon, as well as the ecology of infectious diseases. In his PhD research, he is investigating the prevalence of co-infection in juvenile salmon. He’s also using eDNA metabarcoding to examine the coastal marine community concurrent with juvenile salmon migration and salmon farm activity. Prior to joining the MK lab, he studied at the University of Notre Dame, majoring in Biology and Math, where he examined the fate and transport of eDNA in experimental streams.",
    "crumbs": [
      "2026 teaching team"
    ]
  },
  {
    "objectID": "about-us.html#prior-year-course-instructors",
    "href": "about-us.html#prior-year-course-instructors",
    "title": "2026 teaching team",
    "section": "Prior year course instructors",
    "text": "Prior year course instructors\nMete Yuksel (Instructor Fall 2023 and Fall 2024)\nZoe Humphries (Instructor Fall 2024)\nVicki Zhang (Instructor Fall 2022 and Fall 2023)\nJames Santangelo (Fall 2018)\nAhmed Hasan (Fall 2018 and Fall 2019)\nAmber Hoi\nLuke Johnston (Fall 2017)\nMadeleine Bonsma-Fisher (Fall 2017, 2018)\nLindsay Coome (Fall 2017, 2018)\nElliott Sales de Andrade (Fall 2017)\nSara Mahallati (Fall 2018)\nLina Tran (Fall 2017)\nJoel Ostblom (Fall 2017. 2018)",
    "crumbs": [
      "2026 teaching team"
    ]
  },
  {
    "objectID": "about-us.html#other-source-material",
    "href": "about-us.html#other-source-material",
    "title": "2026 teaching team",
    "section": "Other source material",
    "text": "Other source material\n`Data Analysis and Visualization in R for Ecologists’, Data Carpentry, https://datacarpentry.github.io/R-ecology-lesson/\nBrian Seok, François Michonneau, Tobias Busch, Katrin Leinweber, Maneesha Sane, njlyon0, Ed Bennett, Hugo Tavares, Mike Mahoney, Paula Nieto, Susan Washko, Terry Loecke, Wasila Dahdul, xli677, Abhijna Parigi, Aleksander Jankowski, Allison Shay Theobold, Analytics Enlightened LLC, Anna K. Moeller, … vmzhang. (2024). ’datacarpentry/R-ecology-lesson: Data Carpentry: Data Analysis and Visualization in R for Ecologists 2024-07 (v2024.07)’. Zenodo https://zenodo.org/records/12684301\nChristie Bahlai, ‘Reproducible Quantitative Methods’, https://cbahlai.github.io/rqm-template/\nhttps://jose.theoj.org/papers/10.21105/jose.00049.pdf",
    "crumbs": [
      "2026 teaching team"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html",
    "href": "lectures/lec01-downloading-r.html",
    "title": "1  Downloading and installing R",
    "section": "",
    "text": "1.1 Introduction\nThis course uses R, a computing environment that combines numerical analysis tools for linear algebra, a wide range of scientific computing algorithms, functions for classical and modern statistical analysis; and functions for graphics and data visualization. It is based on the programming language S, developed by John Chambers in the 1970s. Today, R is most popular among statisticians, data scientists, biologists, and public health researchers, but is used broadly across many fields.\nWe will use the graphical user interface (GUI) to R, a software called RStudio, throughout this course. Although the GUI makes many tasks easier, it is not necessary to use it when running R. Both methods will be described below.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#installing-r",
    "href": "lectures/lec01-downloading-r.html#installing-r",
    "title": "1  Downloading and installing R",
    "section": "1.2 Installing R",
    "text": "1.2 Installing R\nDownload R, a free software environment for statistical computing and graphics from CRAN, the Comprehensive R Archive Network. Use the links specific to your operating system at the top of the page (i.e., the `precompiled binary distribution’).\n\nFor Mac users: Select the .pkg file for the latest R version. Mac users with an Apple Silicon chip (e.g., M1 or M2) should install the “arm64” version of R, while Mac users with an Intel chip should install the regular (64-bit) version of R. You can check your laptop’s hardware specifications by clicking the Apple icon (top left corner) \\&gt; About This Mac. Once the .pkg file is downloaded to your computer, double click it and follow the prompts to install R\nFor Windows users: Select the base file and download. Run the .exe file that was just downloaded and follow the instructions on screen to install the downloaded software locally on your computer.\nFor Linux users: Follow the links and instructions provided for your distribution\n\nIf you previously downloaded R for another class or purpose, check what version you have. For maximum compatibility with the code provided for the class, ensure that the R version is 4.5.2 (the latest). You can check your R version by opening the R program (or RStudio if you already have it), and at the prompt (indicated by the &gt; ) typing version. If you have an out-of-date version, you have to download a new one following the instructions above (there’s no separate update process).\n![The R terminal](figures/r_console.jpg){width=50%}\nNo laptop? No problem! If you don’t have a laptop computer that allows you to install software (e.g., a tablet or Chromebook), or if your laptop is older and difficult to run resource-heavy programs, you can instead access R and RStudio from your web browser and do you your computations in the cloud using the cloud-based version of RStudio, called POSIT Cloud. Sign up for a free account here. We’ll add you to our EEB313 workspace so you’ll get more cloud credits than a regular free account.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#installing-rstudio",
    "href": "lectures/lec01-downloading-r.html#installing-rstudio",
    "title": "1  Downloading and installing R",
    "section": "1.3 Installing RStudio",
    "text": "1.3 Installing RStudio\nDownload and install RStudio by choosing your specific operating system, then following the instructions to download the software package and install it for your operating system.\nNote: If your have previously installed RStudio but newer versions have been released, it will automatically notify you and provide the link to update it. There is no connection between versions of R and RStudio - you have to update them independently. If you are updating your version of R after opening R Studio, make sure R Studio is restarted and then verify it recognizes the most recent version of R. On Macs, this is usually automatic, but on Windows, it is possible to have multiple versions of R installed, so if you didn’t delete an older version in the process of installing the new one, you might have to tell RStudio which version of R to use.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#navigating-rstudio",
    "href": "lectures/lec01-downloading-r.html#navigating-rstudio",
    "title": "1  Downloading and installing R",
    "section": "1.4 Navigating RStudio",
    "text": "1.4 Navigating RStudio\nRStudio includes the R console, where you can directly type R commands, but also many other convenient functionalities, which makes it easier to get started and to work with R.\nDetails on the different panels you see in RStudio, with pictures, are provided in the EEB R Manual https://rman.eeb.utoronto.ca/getting-stated/navigating-rstudio/. To summarize, the panels are\n\nTop left: The text editor panel. This is where we can write scripts, i.e. putting several commands of code together and saving them as a text document so that they are accessible for later and so that we can execute them all at once by running the script instead of typing them in one by one. You might not see this panel if you’re opening RStudio for the first time. If so, go to File &gt; RScript to open an new R script and give it a name (like my_test.R)\nBottom left: The console is another space we can input code, only now the code is executed immediately and doesn’t get saved at the end.\nTop right: The environment panel, which shows us all the files, functions, and objects we currently loaded into R. To view more details about any of these objects, click on them to visually inspect them.\nBottom right: The files-plots-help panel. This panel shows the files in the current directory (the folder we are working out of), any plots we make later, and also documentation for various packages and functions. Here, the documentation is formatted in a way that is easier to read and also provides links to the related sections.\n\nTo change the appearance of your RStudio, navigate to Tools &gt; Global Options &gt; Appearance. You can change the font and size, and the editor theme. The default is “Textmate”, but if you like dark mode, a good option is “Tomorrow Night Bright”. You can also change how your panels are organized.\nThere are lots of resources providing tips and tricks for navigating RStudio; for example, check out https://www.dataquest.io/blog/rstudio-tips-tricks-shortcuts/",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#coding-in-r",
    "href": "lectures/lec01-downloading-r.html#coding-in-r",
    "title": "1  Downloading and installing R",
    "section": "1.5 Coding in R",
    "text": "1.5 Coding in R\nWithin RStudio, there are a few ways we can run code in R.\nFor short commands that we aren’t likely to want to repeat, we can simply type then into the console, and the answer will be returned immediately, e.g.\n\n&gt; 1+2\n\nWe can similarly to a series of calculations where the current one depends on the prior. However, this method becomes inconvenient for all but the simplest calculations, since it’s more difficult to repeat a series of calculations in an automated way. For this reason, it is more common to write commands in scripts. Scripts are simply series of lines of code saved in a text file.\nTo create a new script, go to File &gt; RScript, give it a name (like my_test.R), and save it. Once you have written the code you want, there are a few ways you can actually get it to run\n\nusing your cursor to highlight all the code text, and then hitting the icon with the green forward arrow and the word `Run’ in the top right of the scripts panel\ntyping &gt;source('mytest.R') at the prompt in the RStudio console\n\nBoth methods result in the same code being run, although in the latter method, the result of each calculation will not be printed off to the console. You need to enclose the statement you wanted displayed in the print() command, i.e. print(2+3)\nComments! Running any code with a # at the beginning of the line results in the line being read as a comment. This means that the calculation which is specified in the line is not processed and the output not returned. Comments are a useful way to keep track of what line(s) of code do, multiple versions of the same code, etc. Usually we use them to make notes about what the code following the comment is doing and why. Its the most basic way of documenting code for others who may use it (as well as our future selves). However, comments are very limited, since they can’t include any text formatting, so for most of this course we’ll instead be using a different type of R script document called a notebook, which allows us to use the R Markdown format, for much nicer documentation and presentation of our results.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#installing-r-packages",
    "href": "lectures/lec01-downloading-r.html#installing-r-packages",
    "title": "1  Downloading and installing R",
    "section": "Installing R packages",
    "text": "Installing R packages\nR packages are basically bundles of functions that perform related tasks. There are many some that will be come with a base install of R since they are considered critical for using R, such as c(), mean(), +, -, etc.\nThere is an official repository for R-packages beyond the base packages called CRAN (Comprehensive R Archive Network). CRAN has thousands of packages, and all these cannot be installed by default, because then base R installation would be huge and most people would only be using a fraction of everything installed on their machine. It would be like if you downloaded the Firefox or Chrome browser and you would get all extensions and add-ons installed by default, or as if your phone came with every app ever made for it already installed when you bought it: quite impractical.\nInstead, individual users tend to download and install only the packages they really need for their work. While this may be efficient in terms of the space in memory taken up by the app, it can lead to some challenges when sharing code, if you’re not careful to ensure that the code is documented to specify the required packages, and to autmoatically download and install then if they’re missing.\n\n1.5.1 TinyTex\nThere is one package we have to install first before we can create PDF reports, which will be necessary for assignments and the project. Copy and paste into the console (where the \\&gt; symbol is) the two lines of code below to install a package called tinytex.\n\ninstall.packages(\"tinytex\") \ntinytex::install_tinytex()\n\n\n\n1.5.2 Tidyverse\ntidyverse1 is a large collection of packages with similar functions, similar to the way Microsoft Word is part of Microsoft Office. tidyverse, as its name may suggest, contains many packages that makes data cleaning and exploring more intuitive and effective. It is basically an entire philosophy on how to handle data and has a massive following.\nThe two tidyverse packages we will be using the most frequently in this course is dplyr and ggplot2. dplyr is great for data wrangling (Lecture 3) and ggplot2 makes killer plots (Lecture 4).\n\nCopy and paste the below code into your console.\n\n\ninstall.packages(c(\"tidyverse\", \"data.table\"), dependencies = TRUE)\n\nDuring installation, if you ever get the below message, click “No”.\n\nIf you get the message “Do you want to install from sources the packages which need compilation? (Yes/no/cancel)” in the Console, type “Yes” and press enter.\n\nCheck that the tidyverse package has been installed correctly. To do this, go to the bottom right pane and click the tab for “Packages”. If you can search for and find the below packages, then they have been installed! They do not need to be checked off. Alternatively, go to the Console and type library(tidyverse) to verify that the package is installed. An error along the lines “there is no package called tidyverse” will be returned if the package is not installed.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#r-notebooks-and-r-markdown",
    "href": "lectures/lec01-downloading-r.html#r-notebooks-and-r-markdown",
    "title": "1  Downloading and installing R",
    "section": "1.6 R Notebooks and R Markdown",
    "text": "1.6 R Notebooks and R Markdown\n\n1.6.1 Creating R notebooks\nIn the RStudio interface, we will be writing code in a format called the R Notebook. As the name entails, this interface works like a notebook for code, as it allows us to save notes about what the code is doing, the code itself, and any output we get, such as plots and tables, all together in the same document.\nIn RStudio you can create a new R Markdown notebook by going to File &gt; R Markdown. It will appear in the same panel as scripts. The file name should end in .Rmd. - Read the guidelines provided in example text in that notebook.\nWhen we are in the notebook, the text we write is normal plain text, just as if we would be writing it in a text document. If we want to execute some R code, we need to insert a code chunk.\nYou insert a code chunk by either clicking the “Insert” button (icon with a green +C in the top right) or pressing Command + Option + i (on Mac/Linux, or Ctrl + Alt + i on Windows) simultaneously. You could also type out the surrounding backticks, but this would take longer. To run a code chunk, you press the green arrow, or Ctrl/Command + Shift + Enter.\n\n1+2\n\n[1] 3\n\n\nAs you can see, the output appears right under the code block.\nThis is a great way to perform explore your data, since you can do your analysis and write comments and conclusions right under it all in the same document. A powerful feature of this workflow is that there is no extra time needed for code documentation and note-taking, since you’re doing your analyses and taking notes at the same time. This makes it great for both taking notes at lectures and to have as a reference when you return to your code in the future.\n\n\n1.6.2 R Markdown\nThe text format we are using in the R Notebook is called R Markdown. This format allows us to combine R code with the Markdown text format, which enables the use of certain characters to specify headings, bullet points, quotations and even citations. A simple example of how to write in Markdown is to use a single asterisk or underscore to emphasize text (*emphasis*) and two asterisks or underscores to strongly emphasize text (**strong emphasis**). When we convert our R Markdown text to other file formats, these will show up as italics and bold typeface, respectively. If you have used WhatsApp, you might already be familiar with this style of writing. In case you haven’t seen it before, you have just learned something about WhatsApp in your quantitative methods class…\nTo learn more about R Markdown, check out this reference. More helpful commands are also provided in the [EEB R Manual](https://rman.eeb.utoronto.ca/basic-r/rmarkdown/)\n\n\n1.6.3 Saving data and generating reports\nTo save our notes, code, and graphs, all we have to do is to save the R Markdown file, and the we can open it in RStudio next time again. However, if we want someone else to look at this, we can’t always just send them the R Notebook file, because they might not have RStudio installed. Another great feature of R Notebooks is that it is really easy to export them to HTML, Microsoft Word, or PDF documents with figures and professional typesetting. There are actually many academic papers that are written entirely in this format and it is great for assignments and reports. (You might even use it to communicate with your collaborators!) Since R Notebook files convert to HTML, it is also easy to publish simple and good-looking websites in it, in which code chunks are embedded nicely within the text.\nLet’s try to create a document in R.\nFirst, let’s set up the YAML block. This is found at the top of your document, and it is where you specify the title of your document, what kind of output you want, etc.\n\n---\ntitle: \"Your title here\"\nauthor: \"Your name here\"\ndate: \"Insert date\"\noutput:\n  pdf_document: default\n---\n\nNext, let’s type code to perform the calculation we did above:\n\n1+2\n\n[1] 3\n\n\nTo create the output document, we say that we “knit” our R Markdown file into, e.g., a PDF. Simply press the Knit button here and the new document will be created. The first time you do this, you might be asked to install some R packages if it’s the first time you’ve done this - go ahead an let them install.\nAs you can see in the knitted document, the title showed up as we would expect, and lines with pound sign(s) in front of them were converted into headers. Most importantly, we can see both the code and its output! Plots are generated directly in the report without us having to cut and paste images! If we change something in the code, we don’t have to find the new images and paste it in again, the correct one will appear right in your code.\nWhen you quit, R will ask you if you want to save the workspace (that is, all of the variables you have defined in this session); in general, you should say “no” to avoid clutter and unintentional confusion of results from different sessions. Note: When you say “yes” to saving your workspace, it is saved in a hidden file named .RData. By default, when you open a new R session in the same directory, this workspace is loaded and a message informing you so is printed: [Previously saved workspace restored]. It is often best practice to turn this feature off completely.\n\n\n1.6.4 A quick note on variables and memory in R notebooks\nWhen you run code in a notebook by simply interacting with the text in the notebook text file (ie via clicking the green `run’ arrow or typing Command+Shift+Enter, any variables or other objects you create will be available in your RStudio projects environment (i.e. viewable in the Environment pane and accessible via the console). However, when you run a document by knitting, it is actually running a separate, private, session of R, and so the output cannot be accessed later. If you want to examine any output produced in a notebook that’s knitted, make sure the notebook itself contains commands to print the objects so they can be seen in the kitted form.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec01-downloading-r.html#footnotes",
    "href": "lectures/lec01-downloading-r.html#footnotes",
    "title": "1  Downloading and installing R",
    "section": "",
    "text": "This course is focused on tidyverse functions, because that seems to be the trend these days. Although all of our teaching material is written in tidy lingo, it is mostly for the sake of consistency. In all honesty, tidy is pretty great, but some functions are more intuitive in base, so most people code in a mix of the two. If you learned base R elsewhere and prefer to use those functions instead, by all means, go ahead. The correct code is code that does what you want it to do.↩︎",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Downloading and installing R</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html",
    "href": "lectures/lec02-basic-r.html",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "",
    "text": "2.1 Lesson Preamble\nNote: This lecture content was originally created by voluntary contributions to Data Carpentry and has been modified to align with the aims of EEB313. Data Carpentry is an organization focused on data literacy, with the objective of teaching skills to researchers to enable them to retrieve, view, manipulate, analyze, and store their and other’s data in an open and reproducible way.\nThe above paragraph is made explicit since it is one of the core features of working with an open language like R. Many smart people willingly and actively share their material publicly, so that others can modify and build off of the material themselves.\nBy being open, we can “stand on the shoulders of giants” and continue to contribute for others to then stand on our shoulders. Not only does this help get work done, but it also adds to a feeling of community. In fact, there is a common saying in the open source world:\nThis saying captures the spirit, generosity, and fun involved in being a part of these open source projects.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#lesson-preamble",
    "href": "lectures/lec02-basic-r.html#lesson-preamble",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "",
    "text": "2.1.1 Learning Objectives\n\nDefine the following terms as they relate to R: call, function, arguments, options.\nUse comments within code blocks.\nDo simple arithmetic operations in R using values and objects.\nCall functions and use arguments to change their default options.\nDefine our own functions\nInspect the content of vectors and manipulate their content.\nCreate for-loops\nDescribe what a data frame is.\nLoad external data from a .csv file into a data frame in R.\n\n2.1.2 Lecture outline\n\nSetting up your R Notebook (10 min)\nCreating objects/variables in R (10 min)\nUsing and writing functions (15 min)\nVectors and data types (10 min)\nSubsetting vectors (15 min)\nMissing data (10 min)\nLoops and vectorization (10 min)\nData set background (10 min)\nWhat are data frames? (10 min)",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#setting-up-the-r-notebook",
    "href": "lectures/lec02-basic-r.html#setting-up-the-r-notebook",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.2 Setting up the R Notebook",
    "text": "2.2 Setting up the R Notebook\nLet’s remove the template RStudio gives us, and add a title of our own.\n---\ntitle: Introduction to R\n---\nThis header block is called the YAML header. This is where we specify whether we want to convert this file to a HTML or PDF file. This will be discussed in more detail in another class. For now, we just care about including the lecture title here. If you are interested in playing with other YAML options, check out this guide.\nUnder this sentence, we will insert our first code chunk. Remember that you insert a code chunk by either clicking the “Insert” button or pressing Ctrl/Cmd + Alt + i simultaneously. To run a code chunk, you press the green arrow, or Ctrl/Cmd + Shift + Enter.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#creating-objects-in-r",
    "href": "lectures/lec02-basic-r.html#creating-objects-in-r",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.3 Creating objects in R",
    "text": "2.3 Creating objects in R\nAs we saw in our first class, you can get output from R simply by typing math in the console:\n\n3 + 5\n\n[1] 8\n\n12 / 7\n\n[1] 1.714286\n\n\nHowever, to do useful and interesting things, we need to assign values to objects.\n\nx &lt;- 3\nx + 5\n\n[1] 8\n\n\nYou can name an object in R almost anything you want:\n\njoel &lt;- 3\njoel + 5\n\n[1] 8\n\n\n\n2.3.0.1 Challenge\nSo far, we have created two variables, joel and x. What is the sum of these variables?\n\n\n2.3.1 Some tips on naming objects\n\nObjects can be given any name: x, current_temperature, thing, or subject_id.\nYou want your object names to be explicit and not too long.\nObject names cannot start with a number: x2 is valid, but 2x is not.\nR is also case sensitive: joel is different from Joel.\nAvoid using the names of existing functions (e.g. mean, df). You can check whether the name is already in use by using tab completion\nGenerally good to use underscores (_) to separate words in variable and function names\n\nIt is also recommended to use nouns for variable names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name variables, etc.). Using a consistent coding style1 makes your code clearer to read for your future self and your collaborators. RStudio will format code for you if you highlight a section of code and press Ctrl/Cmd + Shift + a.\n\n\n2.3.2 Preforming calculations\nWhen assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name:\n\nweight_kg &lt;- 55    # doesn't print anything\n(weight_kg &lt;- 55)  # but putting parentheses around the call prints the value of `weight_kg`\n\n[1] 55\n\nweight_kg          # and so does typing the name of the object\n\n[1] 55\n\n\nThe variable weight_kg is stored in the computer’s memory where R can access it, and we can start doing arithmetic with it efficiently. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg):\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change a variable’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a new variable, weight_lb:\n\nweight_lb &lt;- 2.2 * weight_kg # Actually, 1 kg = 2.204623 lbs\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\n\n2.3.2.1 Challenge\nWhat do you think is the current content of the object weight_lb? 126.5 or 220?\n\nweight_lb\n\n\n\n2.3.2.2 Challenge\nWhat are the values after each statement in the following?\n\nmass &lt;- 47.5\nage  &lt;- 122\nmass &lt;- mass * 2.0      # mass?\nage  &lt;- age - 20        # age?\nmass_index &lt;- mass/age  # mass_index?",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#functions-and-their-arguments",
    "href": "lectures/lec02-basic-r.html#functions-and-their-arguments",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.4 Functions and their arguments",
    "text": "2.4 Functions and their arguments\n\n2.4.1 Understanding functions\nFunctions can be thought of as recipes. You give a few ingredients as input to a function, and it will generate an output based on these ingredients. Just as with baking, both the ingredients and the actual recipe will influence what comes out of the recipe in the end: will it be a cake or a loaf of bread? In R, the inputs to a function are not called ingredients, but rather arguments, and the output is called the return value of the function. A function does not technically have to return a value, but often does so. Functions are used to automate more complicated sets of commands and many of them are already predefined in R. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is:\n\nsqrt(9)\n\n[1] 3\n\n\nWhich is the same as assigning the value to a variable and then passing that variable to the function:\n\na &lt;- 9\nb &lt;- sqrt(a)\nb\n\n[1] 3\n\n\nHere, the value of a is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to variable b. This function is very simple, because it takes just one argument.\nThe return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a dataset, as we will see later on.\nArguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or, if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‘bad values’, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default.\n\n\n2.4.2 Tab-completion\nTo access help about sqrt, we are first going to learn about tab-completion. Type s and press Tab.\n\ns&lt;tab&gt;q\n\nYou can see that R gives you suggestions of what functions and variables are available that start with the letter s, and thanks to RStudio they are formatted in this nice list. There are many suggestions here, so let’s be a bit more specific and append a q, to find what we want. If we press enter or tab again, R will insert the selected option.\nYou can see that R inserts a pair of parentheses together with the name of the function. This is how the function syntax looks for R and many other programming languages, and it means that within these parentheses, we will specify all the arguments (the ingredients) that we want to pass to this function.\nIf we press tab again, R will helpfully display all the available parameters for this function that we can pass an argument to. The word parameter is used to describe the name that the argument can be passed to. More on that later.\n\nsqrt(&lt;tab&gt;\n\nThere are many things in this list, but only one of them is marked in purple. Purple here means that this list item is a parameter we can use for the function, while yellow means that it is a variable that we defined earlier.2\n\n\n2.4.3 Help with defined functions\nTo read the full help about sqrt, we can use the question mark, or type it directly into the help document browser.\n\n?sqrt\n\nAs you can see, sqrt() takes only one argument, x, which needs to be a numerical vector. Don’t worry too much about the fact that it says vector here; we will talk more about that later. Briefly, a numerical vector is one or more numbers. In R, every number is a vector, so you don’t have to do anything special to create a vector. More on vectors later.\nLet’s try a function that can take multiple arguments: round().\n\nround(&lt;tab&gt;)\n?round\n\nIf we try round with a value:\n\nround(3.14159)\n\n[1] 3\n\n\nHere, we’ve called round() with just one argument, 3.14159, and it has returned the value 3. That’s because the default is to round to the nearest whole number, or integer. If we want more digits we can pass an argument to the digits parameter, to specify how many decimals we want to round to.\n\nround(3.14159, digits = 2)\n\n[1] 3.14\n\n\nSo, above we pass the argument 2, to the parameter digits. Knowing this nomenclature is not essential for doing your own data analysis, but it will be very helpful when you are reading through help documents online and in RStudio.\nWe can leave out the word digits since we know it comes as the second parameter, after x.\n\nround(3.14159, 2)\n\n[1] 3.14\n\n\nAs you notice, we have been leaving out x from the beginning. If you provide the names for both the arguments, we can switch their order:\n\nround(digits = 2, x = 3.14159)\n\n[1] 3.14\n\n\nIt’s good practice to put the non-optional arguments (like the number you’re rounding) first in your function call, and to specify the names of all optional arguments. If you don’t, someone reading your code might have to look up the definition of a function with unfamiliar arguments to understand what you’re doing.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#writing-functions",
    "href": "lectures/lec02-basic-r.html#writing-functions",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.5 Writing functions",
    "text": "2.5 Writing functions\nIn this class, you will be working a lot with functions, especially those that someone else has already written. When you type sum, c(), or mean(), you are using a function that has been made previously and built into R. To remove some of the magic around these functions, we will go through how to make a basic function of our own. Let’s start with a simple example where we add two numbers together:\n\nadd_two_numbers &lt;- function(num1, num2) {\n    return(num1 + num2)\n}\nadd_two_numbers(4, 5)\n\n[1] 9\n\n\nAs you can see, running this function on two numbers returns their sum. We could also assign to a variable in the function and return the function.\n\nadd_two_numbers &lt;- function(num1, num2) {\n    my_sum &lt;- num1 + num2\n    return(my_sum)\n}\nadd_two_numbers(4, 5)\n\n[1] 9\n\n\n\n2.5.0.1 Challenge\nCan you write a function that calculates the mean of 3 numbers?",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#vectors-and-data-types",
    "href": "lectures/lec02-basic-r.html#vectors-and-data-types",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.6 Vectors and data types",
    "text": "2.6 Vectors and data types\nA vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, which can be either numbers or characters. We can assign a series of values to a vector using the c() function, which stands for “concatenate (combine/connect one after another) values into a vector” For example we can create a vector of animal weights and assign it to a new object weight_g:\n\nweight_g &lt;- c(50, 60, 65, 82) # Concatenate/Combine values into a vector\nweight_g\n\n[1] 50 60 65 82\n\n\nYou can also use the built-in command seq, to create a sequence of numbers without typing all of them in manually.\n\nseq(0, 30) # This is the same as just `0:30`\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n[26] 25 26 27 28 29 30\n\nseq(0, 30, 3) # Every third number\n\n [1]  0  3  6  9 12 15 18 21 24 27 30\n\n\nA vector can also contain characters:\n\nanimals &lt;- c('mouse', 'rat', 'dog')\nanimals\n\n[1] \"mouse\" \"rat\"   \"dog\"  \n\n\nThe quotes around “mouse”, “rat”, etc. are essential here and can be either single or double quotes. Without the quotes R will assume there are objects called mouse, rat and dog. As these objects don’t exist in R’s memory, there will be an error message.\nThere are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:\n\nlength(weight_g)\n\n[1] 4\n\nlength(animals)\n\n[1] 3\n\n\nAn important feature of a vector is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object:\n\nclass(weight_g)\n\n[1] \"numeric\"\n\nclass(animals)\n\n[1] \"character\"\n\n\nThe function str() provides an overview of the structure of an object and its elements. It is a useful function when working with large and complex objects:\n\nstr(weight_g)\n\n num [1:4] 50 60 65 82\n\nstr(animals)\n\n chr [1:3] \"mouse\" \"rat\" \"dog\"\n\n\nYou can use the c() function to add other elements to your vector:\n\nweight_g &lt;- c(weight_g, 90) # add to the end of the vector\nweight_g &lt;- c(30, weight_g) # add to the beginning of the vector\nweight_g\n\n[1] 30 50 60 65 82 90\n\n\nIn the first line, we take the original vector weight_g, add the value 90 to the end of it, and save the result back into weight_g. Then we add the value 30 to the beginning, again saving the result back into weight_g.\nWe can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating.\nAn atomic vector is the simplest R data type and it is a linear vector of a single type, e.g. all numbers. Above, we saw 2 of the 6 main atomic vector types that R uses: \"character\" and \"numeric\" (or \"double\"). These are the basic building blocks that all R objects are built from.\nVectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array). In this class, we will focus on data frames, which is most commonly used one for data analyses.\n\n2.6.0.1 Challenge\nWe’ve seen that atomic vectors can be of type character, numeric (or double), integer, and logical. But what happens if we try to mix these types in a single vector? Find out by using class to test these examples.\n\nnum_char &lt;- c(1, 2, 3, 'a')\nnum_logical &lt;- c(1, 2, 3, TRUE)\nchar_logical &lt;- c('a', 'b', 'c', TRUE)\ntricky &lt;- c(1, 2, 3, '4')\n\nThis happens because vectors can be of only one data type. Instead of throwing an error and saying that you are trying to mix different types in the same vector, R tries to convert (coerce) the content of this vector to find a “common denominator”. A logical can be turn into 1 or 0, and a number can be turned into a string/character representation. It would be difficult to do it the other way around: would 5 be TRUE or FALSE? What number would ‘t’ be?\nIn R, we call converting objects from one class into another class coercion. These conversions happen according to a hierarchy, whereby some types get preferentially coerced into other types. Can you draw a diagram that represents the hierarchy of how these data types are coerced?\nThis can be important to watch for in data sets that you import.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#subsetting-vectors",
    "href": "lectures/lec02-basic-r.html#subsetting-vectors",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.7 Subsetting vectors",
    "text": "2.7 Subsetting vectors\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\nanimals &lt;- c(\"mouse\", \"rat\", \"dog\", \"cat\")\nanimals[2]\n\n[1] \"rat\"\n\nanimals[c(3, 2)]\n\n[1] \"dog\" \"rat\"\n\n\nWe can also repeat the indices to create an object with more elements than the original one:\n\nmore_animals &lt;- animals[c(1, 2, 3, 2, 1, 4)]\nmore_animals\n\n[1] \"mouse\" \"rat\"   \"dog\"   \"rat\"   \"mouse\" \"cat\"  \n\n\nR indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that was historically simpler for computers and can allow for more elegant code.\n\n2.7.1 Conditional subsetting\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\nweight_g &lt;- c(21, 34, 39, 54, 55)\nweight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 21 39 54\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50:\n\nweight_g &gt; 50    # will return logicals with TRUE for the indices that meet the condition\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n## so we can use this to select only the values above 50\nweight_g[weight_g &gt; 50]\n\n[1] 54 55\n\n\nWe will consider conditions in more detail in the next few lectures.\n\n\n2.7.2 Strings (character vectors)\nJust a small note about character vectors, also called strings. There are built-in packages for subsetting them that we’ll learn about later. They can be particularly relevant for ecological and genomic data because important data can be nested in complicated strings of text (ex: extracting only the observations that occurred in wet habitats from a column of habitat descriptions or only genes with functions related to drought tolerance).\n\nstring1 &lt;- \"This is a string\" # you can include spaces between your quotes\nstring2 &lt;- c(string1, \"so is this\") # concatenate with another string\nstring2[2] # can access the second string via subsetting\n\n[1] \"so is this\"\n\n# Playing a bit with declaring variables\n\"You can include 'quotes' in a string\"\n\n[1] \"You can include 'quotes' in a string\"\n\nstring3 &lt;- 'You can include \"quotes\" in a string'\nstring3\n\n[1] \"You can include \\\"quotes\\\" in a string\"\n\n\"You can include \\\"matching quotes\\\" if you 'escape' them with a backslash (\\\\)\"\n\n[1] \"You can include \\\"matching quotes\\\" if you 'escape' them with a backslash (\\\\)\"",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#missing-data",
    "href": "lectures/lec02-basic-r.html#missing-data",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.8 Missing data",
    "text": "2.8 Missing data\nAs R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA.\nWhen doing operations on numbers, most functions will return NA if the data you are working with include missing values. This feature makes it harder to overlook the cases where you are dealing with missing data. You can add the argument na.rm = TRUE to calculate the result while ignoring the missing values.\n\nheights &lt;- c(2, 4, 4, NA, 6)\nmean(heights)\n\n[1] NA\n\nmax(heights)\n\n[1] NA\n\nmean(heights, na.rm = TRUE)\n\n[1] 4\n\nmax(heights, na.rm = TRUE)\n\n[1] 6\n\n\n\n## Extract those elements which are not missing values.\nheights[!is.na(heights)]\n\n[1] 2 4 4 6\n\n## Returns the object with incomplete cases removed. The returned object is an atomic vector of type `\"numeric\"` (or `\"double\"`).\nna.omit(heights)\n\n[1] 2 4 4 6\nattr(,\"na.action\")\n[1] 4\nattr(,\"class\")\n[1] \"omit\"\n\n## Extract those elements which are complete cases. The returned object is an atomic vector of type `\"numeric\"` (or `\"double\"`).\nheights[complete.cases(heights)]\n\n[1] 2 4 4 6\n\n\nRecall that you can use the class() function to find the type of your atomic vector.\n\n2.8.0.1 Challenge\n\nUsing this vector of length measurements, create a new vector with the NAs removed.\n\n\nlengths &lt;- c(10, 24, NA, 18, NA, 20)\n\n\nUse the function median() to calculate the median of the lengths vector.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#loops-and-vectorization",
    "href": "lectures/lec02-basic-r.html#loops-and-vectorization",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.9 Loops and vectorization",
    "text": "2.9 Loops and vectorization\nLoops, specifically for-loops, are essential to programming in general. However, in R, you should avoid them as often as possible because there are more efficient ways of doing things that you should use instead. It is still important that you understand the concept of loops and you might also use them in some of your own functions if there is no vectorized way of going about what you want to do.\nYou can think of a for-loop as: “for each number contained in a list/vector, perform this operation” and the syntax basically says the same thing:\n\nv &lt;- c(2, 4, 6)\nfor (num in v) {\n    print(num)\n}\n\n[1] 2\n[1] 4\n[1] 6\n\n\nInstead of printing out every number to the console, we could also add numbers cumulatively, to calculate the sum of all the numbers in the vector:\n\n# To increment `w` each time, we must first create the variable,\n# which we do by setting `w &lt;- 0`, referred to as initializing.\n# This also ensures that `w` is zero at the start of the loop and\n# doesn't retain the value from last time we ran this code.\nw &lt;- 0\nfor (num in v) {\n    w &lt;- w + num\n}\nw\n\n[1] 12\n\n\nIf we put what we just did inside a function, we have essentially recreated the sum function in R.\n\nmy_sum &lt;- function(input_vector) {\n    vector_sum &lt;- 0\n    for (num in input_vector){\n        vector_sum &lt;- vector_sum + num\n    }\n    return(vector_sum)\n}\n\nmy_sum(v)\n\n[1] 12\n\n\nAlthough this gives us the same output as the built-in function sum, the built-in function has many more optimizations so it is much faster than our function. In R, it is always faster to try to find a way of doing things without writing a loop yourself. When you are reading about R, you might see suggestions that you should try to vectorize your code to make it faster. What people are referring to, is that you should not write for loops in R and instead use the ready-made functions that are much more efficient in working with vectors and essentially performs operations on entire vector at once instead of one number at a time. Conceptually, loops operate on one element at a time while vectorized code operates on all elements of a vector at once.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#dataset-background",
    "href": "lectures/lec02-basic-r.html#dataset-background",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.10 Dataset background",
    "text": "2.10 Dataset background\nToday, we will be working with real data from a longitudinal study of the species abundance in the Chihuahuan desert ecosystem near Portal, Arizona, USA. This study includes observations of plants, ants, and rodents from 1977 - 2002, and has been used in over 100 publications. More information is available in the abstract of this paper from 2009. There are several datasets available related to this study, and we will be working with datasets that have been preprocessed by the Data Carpentry to facilitate teaching. These are made available online as The Portal Project Teaching Database, both at the Data Carpentry website, and on Figshare. Figshare is a great place to publish data, code, figures, and more openly to make them available for other researchers and to communicate findings that are not part of a longer paper.\n\n2.10.1 Presentation of the survey data\nWe are studying the species and weight of animals caught in plots in our study area. The dataset is stored as a comma separated value (CSV) file. Each row holds information for a single animal, and the columns represent:\n\n\n\nColumn\nDescription\n\n\n\n\nrecord_id\nunique id for the observation\n\n\nmonth\nmonth of observation\n\n\nday\nday of observation\n\n\nyear\nyear of observation\n\n\nplot_id\nID of a particular plot\n\n\nspecies_id\n2-letter code\n\n\nsex\nsex of animal (“M”, “F”)\n\n\nhindfoot_length\nlength of the hindfoot in mm\n\n\nweight\nweight of the animal in grams\n\n\ngenus\ngenus of animal\n\n\nspecies\nspecies of animal\n\n\ntaxa\ne.g. rodent, reptile, bird, rabbit\n\n\nplot_type\ntype of plot\n\n\n\nTo read the data into R, we are going to use a function called read_csv. This function is contained in an R-package called readr. R-packages are a bit like browser extensions; they are not essential, but can provide nifty functionality. We will go through R-packages in general and which ones are good for data analyses. One useful option that read_csv includes, is the ability to read a CSV file directly from a URL, without downloading it in a separate step:\n\nsurveys &lt;- readr::read_csv('https://ndownloader.figshare.com/files/2292169')\n\nHowever, it is often a good idea to download the data first, so you have a copy stored locally on your computer in case you want to do some offline analyses, or the online version of the file changes or the file is taken down. You can either download the data manually or from within R:\n\ndownload.file(\"https://ndownloader.figshare.com/files/2292169\",\n              \"data/portal_data.csv\") # Saves to current directory with this name\n\nThe data is read in by specifying its local path.\n\nsurveys &lt;- readr::read_csv('data/portal_data.csv')\n\nRows: 34786 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): species_id, sex, genus, species, taxa, plot_type\ndbl (7): record_id, month, day, year, plot_id, hindfoot_length, weight\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThis statement produces some output regarding which data type it found in each column. If we want to check this in more detail, we can print the variable’s value: surveys.\n\nsurveys\n\n# A tibble: 34,786 × 13\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2        72     8    19  1977       2 NL         M                  31     NA\n 3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n 4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n 5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 7       435    12    10  1977       2 NL         &lt;NA&gt;               NA     NA\n 8       506     1     8  1978       2 NL         &lt;NA&gt;               NA     NA\n 9       588     2    18  1978       2 NL         M                  NA    218\n10       661     3    11  1978       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 34,776 more rows\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\nThis displays a nice tabular view of the data, which also includes pagination when there are many rows and we can click the arrow to view all the columns. Technically, this object is actually a tibble rather than a data frame, as indicated in the output. The reason for this is that read_csv automatically converts the data into to a tibble when loading it. Since a tibble is just a data frame with some convenient extra functionality, we will use these words interchangeably from now on.\nIf we just want to glance at how the data frame looks, it is sufficient to display only the top (the first 6 lines) using the function head():\n\nhead(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#what-are-data-frames",
    "href": "lectures/lec02-basic-r.html#what-are-data-frames",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.11 What are data frames?",
    "text": "2.11 What are data frames?\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting. A data frame can be created by hand, but most commonly they are generated by the function read_csv(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is a representation of data in the format of a table where the columns are vectors that all have the same length. Because the columns are vectors, they all contain the same type of data as we discussed in last class (e.g., characters, integers, factors). We can see this when inspecting the structure of a data frame with the function str():\n\nstr(surveys)\n\nspc_tbl_ [34,786 × 13] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ record_id      : num [1:34786] 1 72 224 266 349 363 435 506 588 661 ...\n $ month          : num [1:34786] 7 8 9 10 11 11 12 1 2 3 ...\n $ day            : num [1:34786] 16 19 13 16 12 12 10 8 18 11 ...\n $ year           : num [1:34786] 1977 1977 1977 1977 1977 ...\n $ plot_id        : num [1:34786] 2 2 2 2 2 2 2 2 2 2 ...\n $ species_id     : chr [1:34786] \"NL\" \"NL\" \"NL\" \"NL\" ...\n $ sex            : chr [1:34786] \"M\" \"M\" NA NA ...\n $ hindfoot_length: num [1:34786] 32 31 NA NA NA NA NA NA NA NA ...\n $ weight         : num [1:34786] NA NA NA NA NA NA NA NA 218 NA ...\n $ genus          : chr [1:34786] \"Neotoma\" \"Neotoma\" \"Neotoma\" \"Neotoma\" ...\n $ species        : chr [1:34786] \"albigula\" \"albigula\" \"albigula\" \"albigula\" ...\n $ taxa           : chr [1:34786] \"Rodent\" \"Rodent\" \"Rodent\" \"Rodent\" ...\n $ plot_type      : chr [1:34786] \"Control\" \"Control\" \"Control\" \"Control\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   record_id = col_double(),\n  ..   month = col_double(),\n  ..   day = col_double(),\n  ..   year = col_double(),\n  ..   plot_id = col_double(),\n  ..   species_id = col_character(),\n  ..   sex = col_character(),\n  ..   hindfoot_length = col_double(),\n  ..   weight = col_double(),\n  ..   genus = col_character(),\n  ..   species = col_character(),\n  ..   taxa = col_character(),\n  ..   plot_type = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nInteger refers to a whole number, such as 1, 2, 3, 4, etc. Numbers with decimals, 1.0, 2.4, 3.333, are referred to as floats. Factors are used to represent categorical data. Factors can be ordered or unordered, and understanding them is necessary for statistical analysis and for plotting. Factors are stored as integers, and have labels (text) associated with these unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings.\n\n2.11.1 Inspecting data.frame objects\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\n\nSize:\n\ndim(surveys) - returns a vector with the number of rows in the first element and the number of columns as the second element (the dimensions of the object)\nnrow(surveys) - returns the number of rows\nncol(surveys) - returns the number of columns\n\nContent:\n\nhead(surveys) - shows the first 6 rows\ntail(surveys) - shows the last 6 rows\n\nNames:\n\nnames(surveys) - returns the column names (synonym of colnames() for data.frame objects)\nrownames(surveys) - returns the row names\n\nSummary:\n\nstr(surveys) - structure of the object and information about the class, length, and content of each column\nsummary(surveys) - summary statistics for each column\n\n\nNote: most of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n2.11.1.1 Challenge\nBased on the output of str(surveys), can you answer the following questions?\n\nWhat is the class of the object surveys?\nHow many rows and how many columns are in this object?\nHow many species have been recorded during these surveys?\n\n\n\n\n2.11.2 Indexing and subsetting data frames\nOur survey data frame has rows and columns (it has 2 dimensions). If we want to extract some specific data from it, we need to specify the “coordinates” we want from it. Row numbers come first, followed by column numbers. When indexing, base R data frames return a different format depending on how we index the data (i.e. either a vector or a data frame), but with enhanced data frames, tibbles, the returned object is almost always a data frame.\n\nsurveys[1, 1]   # first element in the first column of the data frame\n\n# A tibble: 1 × 1\n  record_id\n      &lt;dbl&gt;\n1         1\n\nsurveys[1, 6]   # first element in the 6th column\n\n# A tibble: 1 × 1\n  species_id\n  &lt;chr&gt;     \n1 NL        \n\nsurveys[, 1]    # first column in the data frame\n\n# A tibble: 34,786 × 1\n   record_id\n       &lt;dbl&gt;\n 1         1\n 2        72\n 3       224\n 4       266\n 5       349\n 6       363\n 7       435\n 8       506\n 9       588\n10       661\n# ℹ 34,776 more rows\n\nsurveys[1]      # first column in the data frame\n\n# A tibble: 34,786 × 1\n   record_id\n       &lt;dbl&gt;\n 1         1\n 2        72\n 3       224\n 4       266\n 5       349\n 6       363\n 7       435\n 8       506\n 9       588\n10       661\n# ℹ 34,776 more rows\n\nsurveys[1:3, 7] # first three elements in the 7th column\n\n# A tibble: 3 × 1\n  sex  \n  &lt;chr&gt;\n1 M    \n2 M    \n3 &lt;NA&gt; \n\nsurveys[3, ]    # the 3rd element for all columns\n\n# A tibble: 1 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\nsurveys[1:6, ]  # equivalent to head(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\n: is a special operator that creates numeric vectors of integers in increasing or decreasing order; test 1:10 and 10:1 for instance. This works similarly to seq, which we looked at earlier in class:\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n# We can test if all elements are the same\n0:10 == seq(0,10)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\nall(0:10 == seq(0,10))\n\n[1] TRUE\n\n\nYou can also exclude certain parts of a data frame using the “-” sign:\n\nsurveys[,-1]    # All columns, except the first\n\n# A tibble: 34,786 × 12\n   month   day  year plot_id species_id sex   hindfoot_length weight genus  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;  \n 1     7    16  1977       2 NL         M                  32     NA Neotoma\n 2     8    19  1977       2 NL         M                  31     NA Neotoma\n 3     9    13  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 4    10    16  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 5    11    12  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 6    11    12  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 7    12    10  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 8     1     8  1978       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 9     2    18  1978       2 NL         M                  NA    218 Neotoma\n10     3    11  1978       2 NL         &lt;NA&gt;               NA     NA Neotoma\n# ℹ 34,776 more rows\n# ℹ 3 more variables: species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\nsurveys[-c(7:34786),] # Equivalent to head(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\nAs well as using numeric values to subset a data.frame (or matrix), columns can be called by name, using one of the four following notations: \n\nsurveys[\"species_id\"]       # Result is a data.frame\n\n# A tibble: 34,786 × 1\n   species_id\n   &lt;chr&gt;     \n 1 NL        \n 2 NL        \n 3 NL        \n 4 NL        \n 5 NL        \n 6 NL        \n 7 NL        \n 8 NL        \n 9 NL        \n10 NL        \n# ℹ 34,776 more rows\n\nsurveys[, \"species_id\"]     # Result is a data.frame\n\n# A tibble: 34,786 × 1\n   species_id\n   &lt;chr&gt;     \n 1 NL        \n 2 NL        \n 3 NL        \n 4 NL        \n 5 NL        \n 6 NL        \n 7 NL        \n 8 NL        \n 9 NL        \n10 NL        \n# ℹ 34,776 more rows\n\n\nFor our purposes, these notations are equivalent. RStudio knows about the columns in your data frame, so you can take advantage of the autocompletion feature to get the full and correct column name.\nAnother syntax that is often used to specify column names is $. In this case, the returned object is actually a vector. We will not go into detail about this, but since it is such common usage, it is good to be aware of this.\n\n# We use `head()` since the output from vectors are not automatically cut off\n# and we don't want to clutter the screen with all the `species_id` values\nhead(surveys$species_id)          # Result is a vector\n\n[1] \"NL\" \"NL\" \"NL\" \"NL\" \"NL\" \"NL\"\n\n\n\n2.11.2.1 Challenge\n\nCreate a data.frame (surveys_200) containing only the observations from row 200 of the surveys dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\nUse that number to pull out just that last row in the data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame object (surveys_last) from that last row.\n\nUse nrow() to extract the row that is in the middle of the data frame. Store the content of this row in an object named surveys_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(surveys) keeping just the first through 6th rows of the surveys dataset.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#exporting-data",
    "href": "lectures/lec02-basic-r.html#exporting-data",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "2.12 Exporting data",
    "text": "2.12 Exporting data\nAs you begin to play with your raw data, you may want to export these new, processed, datasets to share them with your collaborators or for archival. Similar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nManually create a new folder called “data-processed” in your directory. Alternatively, get R to help you with it.\n\ndir.create(\"Processed data\")\n\nWe are going to prepare a cleaned up version of the data without NAs.\n\n# Note that this omits observations with NA in *any* column.\n# There is no way to control which columns to use.\nsurveys_complete_naomit &lt;- na.omit(surveys)\n\n# Compare the dimensions of the original and the cleaned data frame\ndim(surveys)\n\n[1] 34786    13\n\ndim(surveys_complete_naomit)\n\n[1] 30676    13\n\n\nNow that our dataset is ready, we can save it as a CSV file in our Processed data folder.\n\n# To save to current directory\nwrite_csv(surveys_complete_naomit, \"surveys_complete_naomit.csv\")\n\n# To save to newly created directory\nwrite_csv(surveys_complete_naomit, \n          file.path(\"~/Processed data\", \"surveys_complete_naomit.csv\"))\n\nNext lecture, we’re going to discuss collaboration with GitHub and go over an intro to the command line.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec02-basic-r.html#footnotes",
    "href": "lectures/lec02-basic-r.html#footnotes",
    "title": "2  Introduction to R: assignment, vectors, functions, strings, loops",
    "section": "",
    "text": "Refer to the tidy style guide for which style to adhere to.↩︎\nThere are a few other symbols as well, all of which can be viewed at the end of this post about RStudio code completion.↩︎",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to R: assignment, vectors, functions, strings, loops</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html",
    "href": "lectures/lec03-data-wrangling.html",
    "title": "3  Manipulating and analyzing data",
    "section": "",
    "text": "3.1 Lesson preamble",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#lesson-preamble",
    "href": "lectures/lec03-data-wrangling.html#lesson-preamble",
    "title": "3  Manipulating and analyzing data",
    "section": "",
    "text": "3.1.1 Learning objectives\n\nDescribe what a data frame is.\nLoad external data from a .csv file into a data frame in R.\nUnderstand the purpose of the dplyr package.\nLearn to use data wrangling commands select, filter, %&gt;%, and mutate from the dplyr package.\nUnderstand the split-apply-combine concept for data analysis.\nUse summarize, group_by, and tally to split a data frame into groups of observations, apply a summary statistics for each group, and then combine the results.\nLearn to switch between long and wide format\n\n3.1.2 Lesson outline\n\nGetting set up with R Markdown and R packages for data analytics\nData set background (10 min)\nWhat are data frames? (10 min)\nSplit-apply-combine techniques in dplyr (25 min)\nUsing group_by and tally to summarize categorical data (20 mins)\nReshaping data (15 mins)",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#set-up",
    "href": "lectures/lec03-data-wrangling.html#set-up",
    "title": "3  Manipulating and analyzing data",
    "section": "3.2 Set up",
    "text": "3.2 Set up\nTo do this lecture, we’ll need to be able to create and knit R Markdown documents, and analyze data using functions contained in the tidyverse package. If you haven’t done either of these tasks before, navigate to the course notes for Lecture 1 and follow the instructions there first.\nWhen we make Markdown documents, we want them to be shareable and reproducible, so it’s good practice to include code to install and load any packages the code requires, even if we’ve already done it ourselves. While packages only need to be installed once (they’ll still be there even if RStudio is closed and reopened again or if R is accessed outside of RStudio), someone we share our code with might have never used them before. Or, if you move from using your code on one computer to another, or one computer to the POSIT Cloud, you’ll need to re-install.\nWe can add code install new packages using the function install.packages(). We’ll pass eval=FALSE to knitr at the top of our code chunk to make sure that the chunk won’t be evaluated when we knit the document, since we don’t really need to install it each time, and this option can be changed by another user. You can find other possible options to pass that can be helpful for formatting your output document.\n\ninstall.packages('tidyverse')\n\nThe two tidyverse packages we will be using the most frequently in this course is dplyr and ggplot2. dplyr is great for data wrangling (Lecture 3) and ggplot2 makes killer plots (Lecture 4).\nTo use functions in the dplyr package, type dplyr:: and then the function name.\n\ndplyr::glimpse(cars) # `glimpse` is similar to `str`\n\nRows: 50\nColumns: 2\n$ speed &lt;dbl&gt; 4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13…\n$ dist  &lt;dbl&gt; 2, 10, 4, 22, 16, 10, 18, 26, 34, 17, 28, 14, 20, 24, 28, 26, 34…\n\n# cars is a built-in data set\n\nSince we will be using this package a lot, it would be a little annoying to have to type dplyr:: every time. We can bypass this step by loading the package into our current environment. Think of this is “opening” the package for your work session.\n\n# We could also do `library(dplyr)`, but we need the rest of the\n# tidyverse packages later, so we might as well import the entire collection.\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nglimpse(cars)\n\nRows: 50\nColumns: 2\n$ speed &lt;dbl&gt; 4, 4, 7, 7, 8, 9, 10, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13…\n$ dist  &lt;dbl&gt; 2, 10, 4, 22, 16, 10, 18, 26, 34, 17, 28, 14, 20, 24, 28, 26, 34…\n\n\nThis needs to be done once for every new R session, and so it is common practice to keep a list of all the packages used at the top of your script or notebook for convenience and load all of it at start up.\nThat’s a lot of red though! What are these warning signs and checks?\nAll the warning signs indicate are the version of R that they were built under. They can frequently be ignored unless your version of R is so old that the packages can no longer be run on R! Note that packages are frequently updated, and functions may become deprecated.\nNext, the warning shows you all the packages that were successfully installed.\nFinally, there are some conflicts! All this means is that there are multiple functions with the same name that may do different things. R prioritizes functions from certain packages over others. So, in this case, the filter() function from dplyr will take precedent over the filter() function from the stats package. If you want to use the latter, use double colons :: to indicate that you are calling a function from a certain package:",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#dataset-background",
    "href": "lectures/lec03-data-wrangling.html#dataset-background",
    "title": "3  Manipulating and analyzing data",
    "section": "3.3 Dataset background",
    "text": "3.3 Dataset background\nToday, we will be working with real data from a longitudinal study of the species abundance in the Chihuahuan desert ecosystem near Portal, Arizona, USA. This study includes observations of plants, ants, and rodents from 1977 - 2002, and has been used in over 100 publications. More information is available in the abstract of this paper from 2009. There are several datasets available related to this study, and we will be working with datasets that have been preprocessed by the Data Carpentry to facilitate teaching. These are made available online as The Portal Project Teaching Database, both at the Data Carpentry website, and on Figshare. Figshare is a great place to publish data, code, figures, and more openly to make them available for other researchers and to communicate findings that are not part of a longer paper.\n\n3.3.1 Presentation of the survey data\nWe are studying the species and weight of animals caught in plots in our study area. The dataset is stored as a comma separated value (CSV) file. Each row holds information for a single animal, and the columns represent:\n\n\n\nColumn\nDescription\n\n\n\n\nrecord_id\nunique id for the observation\n\n\nmonth\nmonth of observation\n\n\nday\nday of observation\n\n\nyear\nyear of observation\n\n\nplot_id\nID of a particular plot\n\n\nspecies_id\n2-letter code\n\n\nsex\nsex of animal (“M”, “F”)\n\n\nhindfoot_length\nlength of the hindfoot in mm\n\n\nweight\nweight of the animal in grams\n\n\ngenus\ngenus of animal\n\n\nspecies\nspecies of animal\n\n\ntaxa\ne.g. rodent, reptile, bird, rabbit\n\n\nplot_type\ntype of plot\n\n\n\nTo read the data into R, we are going to use a function called read_csv. This function is contained in an R-package called readr. R-packages are a bit like browser extensions; they are not essential, but can provide nifty functionality. We will go through R-packages in general and which ones are good for data analyses. One useful option that read_csv includes, is the ability to read a CSV file directly from a URL, without downloading it in a separate step:\n\nlibrary(readr)\n\n\nsurveys &lt;- readr::read_csv('https://ndownloader.figshare.com/files/2292169')\n\nHowever, it is often a good idea to download the data first, so you have a copy stored locally on your computer in case you want to do some offline analyses, or the online version of the file changes or the file is taken down. You can either download the data manually or from within R:\n\ndownload.file(\"https://ndownloader.figshare.com/files/2292169\",\n              \"data/portal_data.csv\") # Saves to current directory with this name\n\nThe data is read in by specifying its local path.\n\nsurveys &lt;- readr::read_csv('data/portal_data.csv')\n\nRows: 34786 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): species_id, sex, genus, species, taxa, plot_type\ndbl (7): record_id, month, day, year, plot_id, hindfoot_length, weight\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThis statement produces some output regarding which data type it found in each column. If we want to check this in more detail, we can print the variable’s value: surveys.\n\nsurveys\n\n# A tibble: 34,786 × 13\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2        72     8    19  1977       2 NL         M                  31     NA\n 3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n 4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n 5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 7       435    12    10  1977       2 NL         &lt;NA&gt;               NA     NA\n 8       506     1     8  1978       2 NL         &lt;NA&gt;               NA     NA\n 9       588     2    18  1978       2 NL         M                  NA    218\n10       661     3    11  1978       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 34,776 more rows\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\nThis displays a nice tabular view of the data, which also includes pagination when there are many rows and we can click the arrow to view all the columns. Technically, this object is actually a tibble rather than a data frame, as indicated in the output. The reason for this is that read_csv automatically converts the data into to a tibble when loading it. Since a tibble is just a data frame with some convenient extra functionality, we will use these words interchangeably from now on.\nIf we just want to glance at how the data frame looks, it is sufficient to display only the top (the first 6 lines) using the function head():\n\nhead(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#what-are-data-frames",
    "href": "lectures/lec03-data-wrangling.html#what-are-data-frames",
    "title": "3  Manipulating and analyzing data",
    "section": "3.4 What are data frames?",
    "text": "3.4 What are data frames?\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting. A data frame can be created by hand, but most commonly they are generated by the function read_csv(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is a representation of data in the format of a table where the columns are vectors that all have the same length. Because the columns are vectors, they all contain the same type of data as we discussed in last class (e.g., characters, integers, factors). We can see this when inspecting the structure of a data frame with the function str():\n\nstr(surveys)\n\nspc_tbl_ [34,786 × 13] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ record_id      : num [1:34786] 1 72 224 266 349 363 435 506 588 661 ...\n $ month          : num [1:34786] 7 8 9 10 11 11 12 1 2 3 ...\n $ day            : num [1:34786] 16 19 13 16 12 12 10 8 18 11 ...\n $ year           : num [1:34786] 1977 1977 1977 1977 1977 ...\n $ plot_id        : num [1:34786] 2 2 2 2 2 2 2 2 2 2 ...\n $ species_id     : chr [1:34786] \"NL\" \"NL\" \"NL\" \"NL\" ...\n $ sex            : chr [1:34786] \"M\" \"M\" NA NA ...\n $ hindfoot_length: num [1:34786] 32 31 NA NA NA NA NA NA NA NA ...\n $ weight         : num [1:34786] NA NA NA NA NA NA NA NA 218 NA ...\n $ genus          : chr [1:34786] \"Neotoma\" \"Neotoma\" \"Neotoma\" \"Neotoma\" ...\n $ species        : chr [1:34786] \"albigula\" \"albigula\" \"albigula\" \"albigula\" ...\n $ taxa           : chr [1:34786] \"Rodent\" \"Rodent\" \"Rodent\" \"Rodent\" ...\n $ plot_type      : chr [1:34786] \"Control\" \"Control\" \"Control\" \"Control\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   record_id = col_double(),\n  ..   month = col_double(),\n  ..   day = col_double(),\n  ..   year = col_double(),\n  ..   plot_id = col_double(),\n  ..   species_id = col_character(),\n  ..   sex = col_character(),\n  ..   hindfoot_length = col_double(),\n  ..   weight = col_double(),\n  ..   genus = col_character(),\n  ..   species = col_character(),\n  ..   taxa = col_character(),\n  ..   plot_type = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nInteger refers to a whole number, such as 1, 2, 3, 4, etc. Numbers with decimals, 1.0, 2.4, 3.333, are referred to as floats. Factors are used to represent categorical data. Factors can be ordered or unordered, and understanding them is necessary for statistical analysis and for plotting. Factors are stored as integers, and have labels (text) associated with these unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings.\n\n3.4.1 Inspecting data.frame objects\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\n\nSize:\n\ndim(surveys) - returns a vector with the number of rows in the first element and the number of columns as the second element (the dimensions of the object)\nnrow(surveys) - returns the number of rows\nncol(surveys) - returns the number of columns\n\nContent:\n\nhead(surveys) - shows the first 6 rows\ntail(surveys) - shows the last 6 rows\n\nNames:\n\nnames(surveys) - returns the column names (synonym of colnames() for data.frame objects)\nrownames(surveys) - returns the row names\n\nSummary:\n\nstr(surveys) - structure of the object and information about the class, length, and content of each column\nsummary(surveys) - summary statistics for each column\n\n\nNote: most of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n3.4.1.1 Challenge\nBased on the output of str(surveys), can you answer the following questions?\n\nWhat is the class of the object surveys?\nHow many rows and how many columns are in this object?\nHow many species have been recorded during these surveys?\n\n\n\n\n3.4.2 Indexing and subsetting data frames\nOur survey data frame has rows and columns (it has 2 dimensions). If we want to extract some specific data from it, we need to specify the “coordinates” we want from it. Row numbers come first, followed by column numbers. When indexing, base R data frames return a different format depending on how we index the data (i.e. either a vector or a data frame), but with enhanced data frames, tibbles, the returned object is almost always a data frame.\n\nsurveys[1, 1]   # first element in the first column of the data frame\n\n# A tibble: 1 × 1\n  record_id\n      &lt;dbl&gt;\n1         1\n\nsurveys[1, 6]   # first element in the 6th column\n\n# A tibble: 1 × 1\n  species_id\n  &lt;chr&gt;     \n1 NL        \n\nsurveys[, 1]    # first column in the data frame\n\n# A tibble: 34,786 × 1\n   record_id\n       &lt;dbl&gt;\n 1         1\n 2        72\n 3       224\n 4       266\n 5       349\n 6       363\n 7       435\n 8       506\n 9       588\n10       661\n# ℹ 34,776 more rows\n\nsurveys[1]      # first column in the data frame\n\n# A tibble: 34,786 × 1\n   record_id\n       &lt;dbl&gt;\n 1         1\n 2        72\n 3       224\n 4       266\n 5       349\n 6       363\n 7       435\n 8       506\n 9       588\n10       661\n# ℹ 34,776 more rows\n\nsurveys[1:3, 7] # first three elements in the 7th column\n\n# A tibble: 3 × 1\n  sex  \n  &lt;chr&gt;\n1 M    \n2 M    \n3 &lt;NA&gt; \n\nsurveys[3, ]    # the 3rd element for all columns\n\n# A tibble: 1 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\nsurveys[1:6, ]  # equivalent to head(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\n: is a special operator that creates numeric vectors of integers in increasing or decreasing order; test 1:10 and 10:1 for instance. This works similarly to seq, which we looked at earlier in class:\n\n0:10\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 10)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n# We can test if all elements are the same\n0:10 == seq(0,10)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\nall(0:10 == seq(0,10))\n\n[1] TRUE\n\n\nYou can also exclude certain parts of a data frame using the “-” sign:\n\nsurveys[,-1]    # All columns, except the first\n\n# A tibble: 34,786 × 12\n   month   day  year plot_id species_id sex   hindfoot_length weight genus  \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;  \n 1     7    16  1977       2 NL         M                  32     NA Neotoma\n 2     8    19  1977       2 NL         M                  31     NA Neotoma\n 3     9    13  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 4    10    16  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 5    11    12  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 6    11    12  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 7    12    10  1977       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 8     1     8  1978       2 NL         &lt;NA&gt;               NA     NA Neotoma\n 9     2    18  1978       2 NL         M                  NA    218 Neotoma\n10     3    11  1978       2 NL         &lt;NA&gt;               NA     NA Neotoma\n# ℹ 34,776 more rows\n# ℹ 3 more variables: species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\nsurveys[-c(7:34786),] # Equivalent to head(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n1         1     7    16  1977       2 NL         M                  32     NA\n2        72     8    19  1977       2 NL         M                  31     NA\n3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\nAs well as using numeric values to subset a data.frame (or matrix), columns can be called by name, using one of the four following notations: \n\nsurveys[\"species_id\"]       # Result is a data.frame\n\n# A tibble: 34,786 × 1\n   species_id\n   &lt;chr&gt;     \n 1 NL        \n 2 NL        \n 3 NL        \n 4 NL        \n 5 NL        \n 6 NL        \n 7 NL        \n 8 NL        \n 9 NL        \n10 NL        \n# ℹ 34,776 more rows\n\nsurveys[, \"species_id\"]     # Result is a data.frame\n\n# A tibble: 34,786 × 1\n   species_id\n   &lt;chr&gt;     \n 1 NL        \n 2 NL        \n 3 NL        \n 4 NL        \n 5 NL        \n 6 NL        \n 7 NL        \n 8 NL        \n 9 NL        \n10 NL        \n# ℹ 34,776 more rows\n\n\nFor our purposes, these notations are equivalent. RStudio knows about the columns in your data frame, so you can take advantage of the autocompletion feature to get the full and correct column name.\nAnother syntax that is often used to specify column names is $. In this case, the returned object is actually a vector. We will not go into detail about this, but since it is such common usage, it is good to be aware of this.\n\n# We use `head()` since the output from vectors are not automatically cut off\n# and we don't want to clutter the screen with all the `species_id` values\nhead(surveys$species_id)          # Result is a vector\n\n[1] \"NL\" \"NL\" \"NL\" \"NL\" \"NL\" \"NL\"\n\n\n\n3.4.2.1 Challenge\n\nCreate a data.frame (surveys_200) containing only the observations from row 200 of the surveys dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\nUse that number to pull out just that last row in the data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame object (surveys_last) from that last row.\n\nUse nrow() to extract the row that is in the middle of the data frame. Store the content of this row in an object named surveys_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(surveys) keeping just the first through 6th rows of the surveys dataset.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#exporting-data",
    "href": "lectures/lec03-data-wrangling.html#exporting-data",
    "title": "3  Manipulating and analyzing data",
    "section": "3.5 Exporting data",
    "text": "3.5 Exporting data\nAs you begin to play with your raw data, you may want to export these new, processed, datasets to share them with your collaborators or for archival. Similar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nManually create a new folder called “data-processed” in your directory. Alternatively, get R to help you with it.\n\ndir.create(\"Processed data\")\n\nWe are going to prepare a cleaned up version of the data without NAs.\n\n# Note that this omits observations with NA in *any* column.\n# There is no way to control which columns to use.\nsurveys_complete_naomit &lt;- na.omit(surveys)\n\n# Compare the dimensions of the original and the cleaned data frame\ndim(surveys)\n\n[1] 34786    13\n\ndim(surveys_complete_naomit)\n\n[1] 30676    13\n\n\nNow that our dataset is ready, we can save it as a CSV file in our Processed data folder.\n\n# To save to current directory\nwrite_csv(surveys_complete_naomit, \"surveys_complete_naomit.csv\")\n\n# To save to newly created directory\nwrite_csv(surveys_complete_naomit, \n          file.path(\"Processed data\", \n                    \"surveys_complete_naomit.csv\"))",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#section",
    "href": "lectures/lec03-data-wrangling.html#section",
    "title": "3  Manipulating and analyzing data",
    "section": "3.6 ",
    "text": "3.6",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#data-wrangling-with-dplyr",
    "href": "lectures/lec03-data-wrangling.html#data-wrangling-with-dplyr",
    "title": "3  Manipulating and analyzing data",
    "section": "3.7 Data wrangling with dplyr",
    "text": "3.7 Data wrangling with dplyr\nWrangling here is used in the sense of maneuvering, managing, controlling, and turning your data upside down and inside out to look at it from different angles in order to understand it. The package dplyr provides easy tools for the most common data manipulation tasks. It is built to work directly with data frames, with many common tasks optimized by being written in a compiled language (C++), this means that many operations run much faster than similar tools in R. An additional feature is the ability to work directly with data stored in an external database, such as SQL-databases. The ability to work with databases is great because you are able to work with much bigger datasets (100s of GB) than your computer could normally handle. We will not talk in detail about this in class, but there are great resources online to learn more (e.g. this lecture from Data Carpentry).\n\n3.7.1 Selecting columns and filtering rows\nWe’re going to learn some of the most common dplyr functions: select(), filter(), mutate(), group_by(), and summarise(). To select columns of a data frame, use select(). The first argument to this function is the data frame (surveys), and the subsequent arguments are the columns to keep. Note that we don’t need quotation marks around the column names here like with did with base R. You do still need quotation marks around strings, though!\n\n\n# A tibble: 34,786 × 4\n   plot_id species_id weight  year\n     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1       2 NL             NA  1977\n 2       2 NL             NA  1977\n 3       2 NL             NA  1977\n 4       2 NL             NA  1977\n 5       2 NL             NA  1977\n 6       2 NL             NA  1977\n 7       2 NL             NA  1977\n 8       2 NL             NA  1978\n 9       2 NL            218  1978\n10       2 NL             NA  1978\n# ℹ 34,776 more rows\n\n\nTo choose rows based on a specific criteria, use filter():\n\n\n# A tibble: 1,180 × 13\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1     22314     6     7  1995       2 NL         M                  34     NA\n 2     22728     9    23  1995       2 NL         F                  32    165\n 3     22899    10    28  1995       2 NL         F                  32    171\n 4     23032    12     2  1995       2 NL         F                  33     NA\n 5     22003     1    11  1995       2 DM         M                  37     41\n 6     22042     2     4  1995       2 DM         F                  36     45\n 7     22044     2     4  1995       2 DM         M                  37     46\n 8     22105     3     4  1995       2 DM         F                  37     49\n 9     22109     3     4  1995       2 DM         M                  37     46\n10     22168     4     1  1995       2 DM         M                  36     48\n# ℹ 1,170 more rows\n# ℹ 4 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;\n\n\n\n3.7.1.1 An aside on conditionals\nNote that to check for equality, R requires two equal signs (==). This is to prevent confusion with object assignment, since otherwise year = 1995 might be interpreted as ‘set the year parameter to 1995’, which is not what filter does!\nBasic conditionals in R are broadly similar to how they’re already expressed mathematically:\n\n2 &lt; 3\n\n[1] TRUE\n\n5 &gt; 9\n\n[1] FALSE\n\n\nHowever, there are a few idiosyncrasies to be mindful of for other conditionals:\n\n2 != 3 # not equal\n\n[1] TRUE\n\n2 &lt;= 3 # less than or equal to\n\n[1] TRUE\n\n5 &gt;= 9 # greater than or equal to\n\n[1] FALSE\n\n\nFinally, the %in% operator is used to check for membership:\n\n2 %in% c(2, 3, 4) # check whether 2 in c(2, 3, 4)\n\n[1] TRUE\n\n\nAll of the above conditionals are compatible with filter, with the key difference being that filter expects column names as part of conditional statements instead of individual numbers.\n\n\n\n3.7.2 Chaining functions together using pipes\nBut what if you wanted to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes. With intermediate steps, you essentially create a temporary data frame and use that as input to the next function. This can clutter up your workspace with lots of objects:\n\n\n# A tibble: 1,180 × 4\n   plot_id species_id weight  year\n     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1       2 NL             NA  1995\n 2       2 NL            165  1995\n 3       2 NL            171  1995\n 4       2 NL             NA  1995\n 5       2 DM             41  1995\n 6       2 DM             45  1995\n 7       2 DM             46  1995\n 8       2 DM             49  1995\n 9       2 DM             46  1995\n10       2 DM             48  1995\n# ℹ 1,170 more rows\n\n\nYou can also nest functions (i.e. one function inside of another). This is handy, but can be difficult to read if too many functions are nested as things are evaluated from the inside out. Readability can be mildly improved by enabling “rainbow parentheses” (open settings &gt; Code &gt; Display and check rainbow parentheses), but it’s still basically impossible to document and effectively convey your work with this method.\n\nfilter(select(surveys, plot_id, species_id, weight, year), year == 1995)\n\n# A tibble: 1,180 × 4\n   plot_id species_id weight  year\n     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1       2 NL             NA  1995\n 2       2 NL            165  1995\n 3       2 NL            171  1995\n 4       2 NL             NA  1995\n 5       2 DM             41  1995\n 6       2 DM             45  1995\n 7       2 DM             46  1995\n 8       2 DM             49  1995\n 9       2 DM             46  1995\n10       2 DM             48  1995\n# ℹ 1,170 more rows\n\n\nThe last option, pipes, are a fairly recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %&gt;% and are made available via the magrittr package that also is included in the tidyverse. If you use RStudio, you can type the pipe with Ctrl/Cmd + Shift + M.\n\nsurveys %&gt;% \n    select(., plot_id, species_id, weight, year) %&gt;% \n    filter(., year == 1995)\n\n# A tibble: 1,180 × 4\n   plot_id species_id weight  year\n     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1       2 NL             NA  1995\n 2       2 NL            165  1995\n 3       2 NL            171  1995\n 4       2 NL             NA  1995\n 5       2 DM             41  1995\n 6       2 DM             45  1995\n 7       2 DM             46  1995\n 8       2 DM             49  1995\n 9       2 DM             46  1995\n10       2 DM             48  1995\n# ℹ 1,170 more rows\n\n\nThe . refers to the object that is passed from the previous line. In this example, the data frame surveys is passed to the . in the select() statement. Then, the modified data frame which is the result of the select() operation, is passed to the . in the filter() statement. Put more simply: whatever was the result from the line above the current line, will be used in the current line.\nSince it gets a bit tedious to write out all the dots, dplyr allows for them to be omitted. By default, the pipe will pass its input to the first argument of the right hand side function; in dplyr, the first argument is always a data frame. The chunk below gives the same output as the one above:\n\nsurveys %&gt;% \n    select(plot_id, species_id, weight, year) %&gt;% \n    filter(year == 1995)\n\n# A tibble: 1,180 × 4\n   plot_id species_id weight  year\n     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1       2 NL             NA  1995\n 2       2 NL            165  1995\n 3       2 NL            171  1995\n 4       2 NL             NA  1995\n 5       2 DM             41  1995\n 6       2 DM             45  1995\n 7       2 DM             46  1995\n 8       2 DM             49  1995\n 9       2 DM             46  1995\n10       2 DM             48  1995\n# ℹ 1,170 more rows\n\n\nAnother example:\n\nsurveys %&gt;%\n  filter(weight &lt; 5) %&gt;%\n  select(species_id, sex, weight)\n\n# A tibble: 17 × 3\n   species_id sex   weight\n   &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt;\n 1 PF         F          4\n 2 PF         F          4\n 3 PF         M          4\n 4 RM         F          4\n 5 RM         M          4\n 6 PF         &lt;NA&gt;       4\n 7 PP         M          4\n 8 RM         M          4\n 9 RM         M          4\n10 RM         M          4\n11 PF         M          4\n12 PF         F          4\n13 RM         M          4\n14 RM         M          4\n15 RM         F          4\n16 RM         M          4\n17 RM         M          4\n\n\nIn the above code, we use the pipe to send the surveys dataset first through filter() to keep rows where weight is less than 5, then through select() to keep only the species_id, sex, and weight columns. Since %&gt;% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include it as an argument to the filter() and select() functions anymore.\nIf this runs off your screen and you just want to see the first few rows, you can use a pipe to view the head() of the data. (Pipes work with non-dplyr functions, too, as long as either the dplyr or magrittr package is loaded).\n\nsurveys %&gt;%\n  filter(weight &lt; 5) %&gt;%\n  select(species_id, sex, weight) %&gt;% \n  head()\n\n# A tibble: 6 × 3\n  species_id sex   weight\n  &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt;\n1 PF         F          4\n2 PF         F          4\n3 PF         M          4\n4 RM         F          4\n5 RM         M          4\n6 PF         &lt;NA&gt;       4\n\n\nIf we wanted to create a new object with this smaller version of the data, we could do so by assigning it a new name:\n\nsurveys_sml &lt;- surveys %&gt;%\n  filter(weight &lt; 5) %&gt;%\n  select(species_id, sex, weight)\n\nsurveys_sml\n\n# A tibble: 17 × 3\n   species_id sex   weight\n   &lt;chr&gt;      &lt;chr&gt;  &lt;dbl&gt;\n 1 PF         F          4\n 2 PF         F          4\n 3 PF         M          4\n 4 RM         F          4\n 5 RM         M          4\n 6 PF         &lt;NA&gt;       4\n 7 PP         M          4\n 8 RM         M          4\n 9 RM         M          4\n10 RM         M          4\n11 PF         M          4\n12 PF         F          4\n13 RM         M          4\n14 RM         M          4\n15 RM         F          4\n16 RM         M          4\n17 RM         M          4\n\n\nNote that the final data frame is the leftmost part of this expression.\nA single expression can also be used to filter for several criteria, either matching all criteria (&) or any criteria (|):\n\nsurveys %&gt;% \n    filter(taxa == 'Rodent' & sex == 'F') %&gt;% \n    select(sex, taxa)\n\n# A tibble: 15,690 × 2\n   sex   taxa  \n   &lt;chr&gt; &lt;chr&gt; \n 1 F     Rodent\n 2 F     Rodent\n 3 F     Rodent\n 4 F     Rodent\n 5 F     Rodent\n 6 F     Rodent\n 7 F     Rodent\n 8 F     Rodent\n 9 F     Rodent\n10 F     Rodent\n# ℹ 15,680 more rows\n\n\n\nsurveys %&gt;% \n    filter(species == 'clarki' | species == 'leucophrys') %&gt;% \n    select(species, taxa)\n\n# A tibble: 3 × 2\n  species    taxa   \n  &lt;chr&gt;      &lt;chr&gt;  \n1 leucophrys Bird   \n2 clarki     Reptile\n3 leucophrys Bird   \n\n\n\n3.7.2.1 Challenge\nUsing pipes, subset the survey data to include individuals collected before 1995 and retain only the columns year, sex, and weight.\n\n\n\n3.7.3 Creating new columns with mutate\nFrequently, you’ll want to create new columns based on the values in existing columns. For instance, you might want to do unit conversions, or find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of weight in kg:\n\nsurveys %&gt;%\n    mutate(weight_kg = weight / 1000)\n\n# A tibble: 34,786 × 14\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2        72     8    19  1977       2 NL         M                  31     NA\n 3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n 4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n 5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 7       435    12    10  1977       2 NL         &lt;NA&gt;               NA     NA\n 8       506     1     8  1978       2 NL         &lt;NA&gt;               NA     NA\n 9       588     2    18  1978       2 NL         M                  NA    218\n10       661     3    11  1978       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 34,776 more rows\n# ℹ 5 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nsurveys %&gt;%\n    mutate(weight_kg = weight / 1000,\n           weight_kg2 = weight_kg * 2)\n\n# A tibble: 34,786 × 15\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2        72     8    19  1977       2 NL         M                  31     NA\n 3       224     9    13  1977       2 NL         &lt;NA&gt;               NA     NA\n 4       266    10    16  1977       2 NL         &lt;NA&gt;               NA     NA\n 5       349    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 6       363    11    12  1977       2 NL         &lt;NA&gt;               NA     NA\n 7       435    12    10  1977       2 NL         &lt;NA&gt;               NA     NA\n 8       506     1     8  1978       2 NL         &lt;NA&gt;               NA     NA\n 9       588     2    18  1978       2 NL         M                  NA    218\n10       661     3    11  1978       2 NL         &lt;NA&gt;               NA     NA\n# ℹ 34,776 more rows\n# ℹ 6 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, weight_kg2 &lt;dbl&gt;\n\n\nThe first few rows of the output are full of NAs, so if we wanted to remove those we could insert a filter() in the chain:\n\nsurveys %&gt;%\n    filter(!is.na(weight)) %&gt;%\n    mutate(weight_kg = weight / 1000)\n\n# A tibble: 32,283 × 14\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;  &lt;dbl&gt;\n 1       588     2    18  1978       2 NL         M                  NA    218\n 2       845     5     6  1978       2 NL         M                  32    204\n 3       990     6     9  1978       2 NL         M                  NA    200\n 4      1164     8     5  1978       2 NL         M                  34    199\n 5      1261     9     4  1978       2 NL         M                  32    197\n 6      1453    11     5  1978       2 NL         M                  NA    218\n 7      1756     4    29  1979       2 NL         M                  33    166\n 8      1818     5    30  1979       2 NL         M                  32    184\n 9      1882     7     4  1979       2 NL         M                  32    206\n10      2133    10    25  1979       2 NL         F                  33    274\n# ℹ 32,273 more rows\n# ℹ 5 more variables: genus &lt;chr&gt;, species &lt;chr&gt;, taxa &lt;chr&gt;, plot_type &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;\n\n\nis.na() is a function that determines whether something is an NA. The ! symbol negates the result, so we’re asking for everything that is not an NA.\n\n3.7.3.1 Challenge\nCreate a new data frame from the surveys data that meets the following criteria: contains only the species_id column and a new column called hindfoot_half containing values that are half the hindfoot_length values. In this hindfoot_half column, there are no NAs and all values are less than 30.\nHint: think about how the commands should be ordered to produce this data frame!",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#split-apply-combine-techniques-in-dplyr",
    "href": "lectures/lec03-data-wrangling.html#split-apply-combine-techniques-in-dplyr",
    "title": "3  Manipulating and analyzing data",
    "section": "3.8 Split-apply-combine techniques in dplyr",
    "text": "3.8 Split-apply-combine techniques in dplyr\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results.\ndplyr facilitates this workflow through the use of group_by() to split data and summarize(), which collapses each group into a single-row summary of that group. The arguments to group_by() are the column names that contain the categorical variables for which you want to calculate the summary statistics. Let’s view the mean weight by sex.\n\nsurveys %&gt;%\n    group_by(sex) %&gt;%\n    summarize(mean_weight = mean(weight))\n\n# A tibble: 3 × 2\n  sex   mean_weight\n  &lt;chr&gt;       &lt;dbl&gt;\n1 F              NA\n2 M              NA\n3 &lt;NA&gt;           NA\n\n\nThe mean weights become NA since there are individual observations that are NA. Let’s remove those observations.\n\nsurveys %&gt;%\n    filter(!is.na(weight)) %&gt;%\n    group_by(sex) %&gt;%\n    summarize(mean_weight = mean(weight))\n\n# A tibble: 3 × 2\n  sex   mean_weight\n  &lt;chr&gt;       &lt;dbl&gt;\n1 F            42.2\n2 M            43.0\n3 &lt;NA&gt;         64.7\n\n\nThere is one row here that is neither male nor female, these are observations where the animal escaped before the sex could not be determined. Let’s remove those as well.\n\nsurveys %&gt;%\n    filter(!is.na(weight) & !is.na(sex)) %&gt;%\n    group_by(sex) %&gt;%\n    summarize(mean_weight = mean(weight))\n\n# A tibble: 2 × 2\n  sex   mean_weight\n  &lt;chr&gt;       &lt;dbl&gt;\n1 F            42.2\n2 M            43.0\n\n\nYou can also group by multiple columns:\n\nsurveys %&gt;%\n    filter(!is.na(weight) & !is.na(sex)) %&gt;%\n    group_by(genus, sex) %&gt;%\n    summarize(mean_weight = mean(weight))\n\n`summarise()` has grouped output by 'genus'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 20 × 3\n# Groups:   genus [10]\n   genus           sex   mean_weight\n   &lt;chr&gt;           &lt;chr&gt;       &lt;dbl&gt;\n 1 Baiomys         F            9.16\n 2 Baiomys         M            7.36\n 3 Chaetodipus     F           23.8 \n 4 Chaetodipus     M           24.7 \n 5 Dipodomys       F           55.2 \n 6 Dipodomys       M           56.2 \n 7 Neotoma         F          154.  \n 8 Neotoma         M          166.  \n 9 Onychomys       F           26.8 \n10 Onychomys       M           26.2 \n11 Perognathus     F            8.57\n12 Perognathus     M            8.20\n13 Peromyscus      F           22.5 \n14 Peromyscus      M           20.6 \n15 Reithrodontomys F           11.2 \n16 Reithrodontomys M           10.2 \n17 Sigmodon        F           71.7 \n18 Sigmodon        M           61.3 \n19 Spermophilus    F           57   \n20 Spermophilus    M          130   \n\n\nSince we will use the same filtered and grouped data frame in multiple code chunks below, we could assign this subset of the data to a new variable and use this variable in the subsequent code chunks instead of typing out the functions each time.\n\nfiltered_surveys &lt;- surveys %&gt;%\n    filter(!is.na(weight) & !is.na(sex)) %&gt;%\n    group_by(genus, sex)\n\nIf you want to display more data, you can use the print() function at the end of your chain with the argument n specifying the number of rows to display.\n\nfiltered_surveys %&gt;%\n    summarize(mean_weight = mean(weight)) %&gt;%\n    print(n = 15) # Will change the knitted output, not the notebook\n\n`summarise()` has grouped output by 'genus'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 20 × 3\n# Groups:   genus [10]\n   genus           sex   mean_weight\n   &lt;chr&gt;           &lt;chr&gt;       &lt;dbl&gt;\n 1 Baiomys         F            9.16\n 2 Baiomys         M            7.36\n 3 Chaetodipus     F           23.8 \n 4 Chaetodipus     M           24.7 \n 5 Dipodomys       F           55.2 \n 6 Dipodomys       M           56.2 \n 7 Neotoma         F          154.  \n 8 Neotoma         M          166.  \n 9 Onychomys       F           26.8 \n10 Onychomys       M           26.2 \n11 Perognathus     F            8.57\n12 Perognathus     M            8.20\n13 Peromyscus      F           22.5 \n14 Peromyscus      M           20.6 \n15 Reithrodontomys F           11.2 \n# ℹ 5 more rows\n\n\nOnce the data are grouped, you can also summarize multiple variables at the same time. For instance, we could add a column indicating the minimum weight for each species for each sex:\n\nfiltered_surveys %&gt;%\n    summarize(mean_weight = mean(weight),\n              min_weight = min(weight))\n\n`summarise()` has grouped output by 'genus'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 20 × 4\n# Groups:   genus [10]\n   genus           sex   mean_weight min_weight\n   &lt;chr&gt;           &lt;chr&gt;       &lt;dbl&gt;      &lt;dbl&gt;\n 1 Baiomys         F            9.16          6\n 2 Baiomys         M            7.36          6\n 3 Chaetodipus     F           23.8           5\n 4 Chaetodipus     M           24.7           4\n 5 Dipodomys       F           55.2          10\n 6 Dipodomys       M           56.2          12\n 7 Neotoma         F          154.           32\n 8 Neotoma         M          166.           30\n 9 Onychomys       F           26.8           5\n10 Onychomys       M           26.2           9\n11 Perognathus     F            8.57          4\n12 Perognathus     M            8.20          4\n13 Peromyscus      F           22.5           8\n14 Peromyscus      M           20.6           7\n15 Reithrodontomys F           11.2           4\n16 Reithrodontomys M           10.2           4\n17 Sigmodon        F           71.7          15\n18 Sigmodon        M           61.3          16\n19 Spermophilus    F           57            57\n20 Spermophilus    M          130           130\n\n\n\n3.8.0.1 Challenge\n\nUse group_by() and summarize() to find the mean, min, and max hindfoot length for each species.\nWhat was the heaviest animal measured in each year? Return the columns year, genus, species, and weight.\n\n\n\n3.8.1 Using tally to summarize categorical data\nWhen working with data, it is also common to want to know the number of observations found for each factor or combination of factors. For this, dplyr provides tally(). For example, if we want to group by taxa and find the number of observations for each taxa, we would do:\n\nsurveys %&gt;%\n    group_by(taxa) %&gt;%\n    tally()\n\n# A tibble: 4 × 2\n  taxa        n\n  &lt;chr&gt;   &lt;int&gt;\n1 Bird      450\n2 Rabbit     75\n3 Reptile    14\n4 Rodent  34247\n\n\nWe can also use tally() when grouping on multiple variables:\n\nsurveys %&gt;%\n    group_by(taxa, sex) %&gt;%\n    tally()\n\n# A tibble: 6 × 3\n# Groups:   taxa [4]\n  taxa    sex       n\n  &lt;chr&gt;   &lt;chr&gt; &lt;int&gt;\n1 Bird    &lt;NA&gt;    450\n2 Rabbit  &lt;NA&gt;     75\n3 Reptile &lt;NA&gt;     14\n4 Rodent  F     15690\n5 Rodent  M     17348\n6 Rodent  &lt;NA&gt;   1209\n\n\nHere, tally() is the action applied to the groups created by group_by() and counts the total number of records for each category.\nIf there are many groups, tally() is not that useful on its own. For example, when we want to view the five most abundant species among the observations:\n\nsurveys %&gt;%\n    group_by(species) %&gt;%\n    tally()\n\n# A tibble: 40 × 2\n   species             n\n   &lt;chr&gt;           &lt;int&gt;\n 1 albigula         1252\n 2 audubonii          75\n 3 baileyi          2891\n 4 bilineata         303\n 5 brunneicapillus    50\n 6 chlorurus          39\n 7 clarki              1\n 8 eremicus         1299\n 9 flavus           1597\n10 fulvescens         75\n# ℹ 30 more rows\n\n\nSince there are 40 rows in this output, we would like to order the table to display the most abundant species first. In dplyr, we say that we want to arrange() the data.\n\nsurveys %&gt;%\n    group_by(species) %&gt;%\n    tally() %&gt;%\n    arrange(n)\n\n# A tibble: 40 × 2\n   species          n\n   &lt;chr&gt;        &lt;int&gt;\n 1 clarki           1\n 2 scutalatus       1\n 3 tereticaudus     1\n 4 tigris           1\n 5 uniparens        1\n 6 viridis          1\n 7 leucophrys       2\n 8 savannarum       2\n 9 fuscus           5\n10 undulatus        5\n# ℹ 30 more rows\n\n\nStill not that useful. Since we are interested in the most abundant species, we want to display those with the highest count first, in other words, we want to arrange the column n in descending order:\n\nsurveys %&gt;%\n    group_by(species) %&gt;%\n    tally() %&gt;%\n    arrange(desc(n)) %&gt;%\n    head(5)\n\n# A tibble: 5 × 2\n  species          n\n  &lt;chr&gt;        &lt;int&gt;\n1 merriami     10596\n2 penicillatus  3123\n3 ordii         3027\n4 baileyi       2891\n5 megalotis     2609\n\n\nIf we want to include more attributes about these species, we can include these in the call to group_by():\n\nsurveys %&gt;%\n    group_by(species, taxa, genus) %&gt;%\n    tally() %&gt;%\n    arrange(desc(n)) %&gt;%\n    head(5)\n\n# A tibble: 5 × 4\n# Groups:   species, taxa [5]\n  species      taxa   genus               n\n  &lt;chr&gt;        &lt;chr&gt;  &lt;chr&gt;           &lt;int&gt;\n1 merriami     Rodent Dipodomys       10596\n2 penicillatus Rodent Chaetodipus      3123\n3 ordii        Rodent Dipodomys        3027\n4 baileyi      Rodent Chaetodipus      2891\n5 megalotis    Rodent Reithrodontomys  2609\n\n\nBe careful not to include anything that would split the group into subgroups, such as sex, year etc.\n\n3.8.1.1 Challenge\n\nHow many individuals were caught in each plot_type surveyed?\nYou saw above how to count the number of individuals of each sex using a combination of group_by() and tally(). How could you get the same result using group_by() and summarize()? Hint: see ?n.",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#reshaping-with-pivot_wider-and-pivot_longer",
    "href": "lectures/lec03-data-wrangling.html#reshaping-with-pivot_wider-and-pivot_longer",
    "title": "3  Manipulating and analyzing data",
    "section": "3.9 Reshaping with pivot_wider and pivot_longer",
    "text": "3.9 Reshaping with pivot_wider and pivot_longer\n\n3.9.1 Defining wide vs long data\nThe survey data presented here is almost in what we call a long format – every observation of every individual is its own row. This is an ideal format for data with a rich set of information per observation. It makes it difficult, however, to look at the relationships between measurements across plots/trials. For example, what is the relationship between mean weights of different genera across all plots?\nTo answer that question, we want each plot to have its own row, with each measurements in its own column. This is called a wide data format. For the surveys data as we have it right now, this is going to be one heck of a wide data frame! However, if we were to summarize data within plots and species, we can reduce the dataset and begin to look for some relationships we’d want to examine. We need to create a new table where each row is the values for a particular variable associated with each plot. In practical terms, this means the values in genus would become the names of column variables and the cells would contain the values of the mean weight observed on each plot by genus.\nWe can use the functions called pivot_wider() and pivot_longer() (these are newer replacements for spread() and gather(), which were the older functions). These can feel tricky to think through, but do not feel alone in this! Many others have squinted at their data, unsure exactly how to reshape it, so there are many guides and cheatsheets available to help!\n\n\n3.9.2 Summary of long vs wide formats\nLong format:\n\nevery column is a variable\n\nfirst column(s) repeat\n\nevery row is an observation\n\nWide format:\n\neach row is a measured thing\neach column is an independent observation\n\nfirst column does not repeat\n\n\n\n\n3.9.3 Long to Wide with pivot_wider\nLet’s start by using dplyr to create a data frame with the mean body weight of each genus by plot.\n\nsurveys_gw &lt;- surveys %&gt;%\n    filter(!is.na(weight)) %&gt;%\n    group_by(genus, plot_id) %&gt;%\n    summarize(mean_weight = mean(weight))\n\n`summarise()` has grouped output by 'genus'. You can override using the\n`.groups` argument.\n\nsurveys_gw %&gt;% head()\n\n# A tibble: 6 × 3\n# Groups:   genus [1]\n  genus   plot_id mean_weight\n  &lt;chr&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n1 Baiomys       1        7   \n2 Baiomys       2        6   \n3 Baiomys       3        8.61\n4 Baiomys       5        7.75\n5 Baiomys      18        9.5 \n6 Baiomys      19        9.53\n\n\nNow, to make this long data wide, we use pivot_wider() from tidyr to spread out the different taxa into columns. pivot_wider() takes 3 arguments: the data , the names_from column variable that will eventually become the column names, and the values_from column variable that will fill in the values. We’ll use a pipe so we don’t need to explicitly supply the data argument.\n\nsurveys_gw_wide &lt;- surveys_gw %&gt;% \n  pivot_wider(names_from = genus, values_from = mean_weight)\n\nhead(surveys_gw_wide)\n\n# A tibble: 6 × 11\n  plot_id Baiomys Chaetodipus Dipodomys Neotoma Onychomys Perognathus Peromyscus\n    &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;\n1       1    7           22.2      60.2    156.      27.7        9.62       22.2\n2       2    6           25.1      55.7    169.      26.9        6.95       22.3\n3       3    8.61        24.6      52.0    158.      26.0        7.51       21.4\n4       5    7.75        18.0      51.1    190.      27.0        8.66       21.2\n5      18    9.5         26.8      61.4    149.      26.6        8.62       21.4\n6      19    9.53        26.4      43.3    120       23.8        8.09       20.8\n# ℹ 3 more variables: Reithrodontomys &lt;dbl&gt;, Sigmodon &lt;dbl&gt;, Spermophilus &lt;dbl&gt;\n\n\nNow we can go back to our original question: what is the relationship between mean weights of different genera across all plots? We can easily see the weights for each genus in each plot! Notice that some genera have NA values. That’s because some genera were not recorded in that plot.\nNote! If you’ve been using R for a few years in other contexts, you may have used the function spread()instead of pivot_wider. spread also takes three arguments: the data, the key column (or column with identifying information), and the values column (the one with the numbers/values), and can return the same `wide’ data frame. However pivot_wider is currently the recommended function to use, as it has extra features to make it more flexible and less error_prone.\n\nsurveys_gw_wide0 &lt;- surveys_gw %&gt;%\n  spread(key = genus, value = mean_weight) \n\nhead(surveys_gw_wide0)\n\n# A tibble: 6 × 11\n  plot_id Baiomys Chaetodipus Dipodomys Neotoma Onychomys Perognathus Peromyscus\n    &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;\n1       1    7           22.2      60.2    156.      27.7        9.62       22.2\n2       2    6           25.1      55.7    169.      26.9        6.95       22.3\n3       3    8.61        24.6      52.0    158.      26.0        7.51       21.4\n4       4   NA           23.0      57.5    164.      28.1        7.82       22.6\n5       5    7.75        18.0      51.1    190.      27.0        8.66       21.2\n6       6   NA           24.9      58.6    180.      25.9        7.81       21.8\n# ℹ 3 more variables: Reithrodontomys &lt;dbl&gt;, Sigmodon &lt;dbl&gt;, Spermophilus &lt;dbl&gt;\n\n\n\n\n3.9.4 Wide to long with gather and pivot_longer\nWhat if we had the opposite problem, and wanted to go from a wide to long format? For that, we can use pivot_longer() to gather a set of columns into one key-value pair. To go backwards from surveys_gw_wide, we should exclude plot_id.\npivot_longer() takes 4 arguments: the data, the names_to column variable that comes from the column names, the values_to column with the values, and cols which specifies which columns we want to keep or drop. Again, we will pipe from the dataset so we don’t have to specify the data argument:\n\nsurveys_gw_long2 &lt;- surveys_gw_wide %&gt;% \n  pivot_longer(names_to = \"genus\", values_to = \"mean_weight\", cols = -plot_id)\n\nsurveys_gw_long2\n\n# A tibble: 240 × 3\n   plot_id genus           mean_weight\n     &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;\n 1       1 Baiomys                7   \n 2       1 Chaetodipus           22.2 \n 3       1 Dipodomys             60.2 \n 4       1 Neotoma              156.  \n 5       1 Onychomys             27.7 \n 6       1 Perognathus            9.62\n 7       1 Peromyscus            22.2 \n 8       1 Reithrodontomys       11.4 \n 9       1 Sigmodon              NA   \n10       1 Spermophilus          NA   \n# ℹ 230 more rows\n\n\nIf the columns are directly adjacent as they are here, we don’t even need to list the all out: we can just use the : operator, as before.\n\nsurveys_gw_wide %&gt;% \n  pivot_longer(names_to = \"genus\", values_to = \"mean_weight\", cols = Baiomys:Sigmodon)\n\n# A tibble: 216 × 4\n   plot_id Spermophilus genus           mean_weight\n     &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;\n 1       1           NA Baiomys                7   \n 2       1           NA Chaetodipus           22.2 \n 3       1           NA Dipodomys             60.2 \n 4       1           NA Neotoma              156.  \n 5       1           NA Onychomys             27.7 \n 6       1           NA Perognathus            9.62\n 7       1           NA Peromyscus            22.2 \n 8       1           NA Reithrodontomys       11.4 \n 9       1           NA Sigmodon              NA   \n10       2           NA Baiomys                6   \n# ℹ 206 more rows\n\n\nNote that now the NA genera are included in the long format.\nIn the past, you may have used gather(). We give it the arguments of a new key and value column name, and then specify which columns we either want or do not want gathered up. So, togo backwards from surveys_gw_wide, and exclude plot_id from the gathering, we would do the following:\n\nsurveys_gw_long0 &lt;- surveys_gw_wide0 %&gt;%\n  gather(genus, mean_weight, -plot_id) \n\nhead(surveys_gw_long0)\n\n# A tibble: 6 × 3\n  plot_id genus   mean_weight\n    &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt;\n1       1 Baiomys        7   \n2       2 Baiomys        6   \n3       3 Baiomys        8.61\n4       4 Baiomys       NA   \n5       5 Baiomys        7.75\n6       6 Baiomys       NA   \n\n\n\n\n3.9.5 Challenge\nStarting with the surveys_gw_wide dataset, how would you display a new dataset that gathers the mean weight of all the genera (excluding NAs) except for the genus Perognathus?\n\nsurveys_gw_wide %&gt;%\n  pivot_longer(names_to = \"genus\", values_to = \"mean_weight\",\n               cols = c(-plot_id, -Perognathus))\n\n# A tibble: 216 × 4\n   plot_id Perognathus genus           mean_weight\n     &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;\n 1       1        9.62 Baiomys                 7  \n 2       1        9.62 Chaetodipus            22.2\n 3       1        9.62 Dipodomys              60.2\n 4       1        9.62 Neotoma               156. \n 5       1        9.62 Onychomys              27.7\n 6       1        9.62 Peromyscus             22.2\n 7       1        9.62 Reithrodontomys        11.4\n 8       1        9.62 Sigmodon               NA  \n 9       1        9.62 Spermophilus           NA  \n10       2        6.95 Baiomys                 6  \n# ℹ 206 more rows",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "lectures/lec03-data-wrangling.html#section-1",
    "href": "lectures/lec03-data-wrangling.html#section-1",
    "title": "3  Manipulating and analyzing data",
    "section": "3.10 ",
    "text": "3.10",
    "crumbs": [
      "Lectures",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulating and analyzing data</span>"
    ]
  },
  {
    "objectID": "assignments/assignment-01.html",
    "href": "assignments/assignment-01.html",
    "title": "Assignment 01: Basic R",
    "section": "",
    "text": "1. Using R Markdown notebooks (1 mark)\nDownload the .Rmd file here.\n*To submit this assignment, upload the full .Rmd document, including the original questions, your code, and the output. Submit your assignment as a knitted .pdf (Question 1 walks you through this part, and more details are in course notes).",
    "crumbs": [
      "Assignments",
      "Assignment 01: Basic R"
    ]
  },
  {
    "objectID": "assignments/assignment-01.html#using-r-markdown-notebooks-1-mark",
    "href": "assignments/assignment-01.html#using-r-markdown-notebooks-1-mark",
    "title": "Assignment 01: Basic R",
    "section": "",
    "text": "In RStudio, create a new R Markdown notebook. The file name should end in .Rmd.\nRead the guidelines provided in example text in that notebook\nUse the knit button to run the example notebook and generate a PDF file. You might be asked to install some R packages if it’s the first time you’ve done this - go ahead an let them install\nNext, download the assignment .Rmd file, and either a) open it in RStudio (ignoring the new file you created above) or b) copy the contents into example notebook you already have opened.\nInsert a code chunk below these bullets, write a simple mathematical expression to evaluate (e.g. 1+1), and then run the chunk (green arrow play button in top right of chunk)\nNow knit this notebook again, before proceeding with the rest of the assignment",
    "crumbs": [
      "Assignments",
      "Assignment 01: Basic R"
    ]
  },
  {
    "objectID": "assignments/assignment-01.html#variable-assignment-and-basic-math-1-mark",
    "href": "assignments/assignment-01.html#variable-assignment-and-basic-math-1-mark",
    "title": "Assignment 01: Basic R",
    "section": "2. Variable assignment and basic math (1 mark)",
    "text": "2. Variable assignment and basic math (1 mark)\n\nAssign the value 5 to the variable/object a. Display a. (0.25 marks)\n\n\nAssign the result of 10/3 to the variable b. Display b. (0.25 marks)\n\n\nWrite a function that uses Pythagorean theorem to calculate the length of the longest side (hypotenuse) of a right angle triangle given the lengths of the two other sides. Use it to assign the hypotenuse of a triangle with sides a and b to the variable hypot. Display hypot. (0.5 marks)",
    "crumbs": [
      "Assignments",
      "Assignment 01: Basic R"
    ]
  },
  {
    "objectID": "assignments/assignment-01.html#vectors-3-marks",
    "href": "assignments/assignment-01.html#vectors-3-marks",
    "title": "Assignment 01: Basic R",
    "section": "3. Vectors (3 marks)",
    "text": "3. Vectors (3 marks)\n\nCreate a vector v with all integers 0-30, and a vector w with every third integer in the same range. (0.25 marks)\n\n\nWhat is the difference in lengths of the vectors v and w? (0.25 marks)\n\n\nCreate a new vector, v_square, with the square of elements at indices 3, 6, 7, 10, 15, 22, 23, 24, and 30 from the variable v. Hint: Use indexing rather than a for loop. (0.25 marks)\n\n\nCalculate the mean and median of the first five values from v_square. (0.25 marks)\n\n\nCreate a boolean vector v_bool, indicating which vector v elements are bigger than 20. How many values are over 20? Hint: In R, TRUE = 1, and FALSE = 0, so you can use simple arithmetic to find this out. (0.5 marks)\n\n\nCreate a new vector of character strings v_bool_in_words, that contains the word big if the corresponding element of v is bigger than 20 and small if not (0.5 marks)\n\n\nWrite a function that calculates the median of the any values in a numeric vector greater than “n”. Test this function with the v and v_square vectors and n = 10. (1 marks)",
    "crumbs": [
      "Assignments",
      "Assignment 01: Basic R"
    ]
  }
]